// Code generated by protoc-gen-go-grpc. DO NOT EDIT.

package proto

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	emptypb "google.golang.org/protobuf/types/known/emptypb"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion7

// NetemClient is the client API for Netem service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type NetemClient interface {
	// general action
	GetVersion(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*VersionResponse, error)
	PullImages(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (Netem_PullImagesClient, error)
	Clean(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*AckResponse, error)
	// Project actions
	ProjectGetMany(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*PrjListResponse, error)
	ProjectOpen(ctx context.Context, in *OpenRequest, opts ...grpc.CallOption) (*PrjOpenResponse, error)
	ProjectClose(ctx context.Context, in *ProjectRequest, opts ...grpc.CallOption) (Netem_ProjectCloseClient, error)
	ProjectSave(ctx context.Context, in *ProjectRequest, opts ...grpc.CallOption) (Netem_ProjectSaveClient, error)
	ProjectGetNodeConfigs(ctx context.Context, in *ProjectRequest, opts ...grpc.CallOption) (*FileResponse, error)
	ProjectGetStatus(ctx context.Context, in *ProjectRequest, opts ...grpc.CallOption) (*StatusResponse, error)
	// Read/Write network topology
	ReadNetworkFile(ctx context.Context, in *ProjectRequest, opts ...grpc.CallOption) (*FileResponse, error)
	WriteNetworkFile(ctx context.Context, in *WNetworkRequest, opts ...grpc.CallOption) (*AckResponse, error)
	// topology actions
	Check(ctx context.Context, in *ProjectRequest, opts ...grpc.CallOption) (*AckResponse, error)
	TopologyReload(ctx context.Context, in *ProjectRequest, opts ...grpc.CallOption) (Netem_TopologyReloadClient, error)
	TopologyRun(ctx context.Context, in *ProjectRequest, opts ...grpc.CallOption) (Netem_TopologyRunClient, error)
	TopologyStartAll(ctx context.Context, in *ProjectRequest, opts ...grpc.CallOption) (*AckResponse, error)
	TopologyStopAll(ctx context.Context, in *ProjectRequest, opts ...grpc.CallOption) (*AckResponse, error)
	// Node actions
	ReadConfigFiles(ctx context.Context, in *NodeRequest, opts ...grpc.CallOption) (*ConfigFilesResponse, error)
	CanRunConsole(ctx context.Context, in *NodeRequest, opts ...grpc.CallOption) (*AckResponse, error)
	Console(ctx context.Context, opts ...grpc.CallOption) (Netem_ConsoleClient, error)
	Start(ctx context.Context, in *NodeRequest, opts ...grpc.CallOption) (*AckResponse, error)
	Stop(ctx context.Context, in *NodeRequest, opts ...grpc.CallOption) (*AckResponse, error)
	Restart(ctx context.Context, in *NodeRequest, opts ...grpc.CallOption) (*AckResponse, error)
	SetIfState(ctx context.Context, in *NodeIfStateRequest, opts ...grpc.CallOption) (*AckResponse, error)
	Capture(ctx context.Context, in *NodeInterfaceRequest, opts ...grpc.CallOption) (Netem_CaptureClient, error)
	CopyFrom(ctx context.Context, in *CopyMsg, opts ...grpc.CallOption) (Netem_CopyFromClient, error)
	CopyTo(ctx context.Context, opts ...grpc.CallOption) (Netem_CopyToClient, error)
	// Link actions
	LinkUpdate(ctx context.Context, in *LinkRequest, opts ...grpc.CallOption) (*AckResponse, error)
}

type netemClient struct {
	cc grpc.ClientConnInterface
}

func NewNetemClient(cc grpc.ClientConnInterface) NetemClient {
	return &netemClient{cc}
}

func (c *netemClient) GetVersion(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*VersionResponse, error) {
	out := new(VersionResponse)
	err := c.cc.Invoke(ctx, "/netem.Netem/GetVersion", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *netemClient) PullImages(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (Netem_PullImagesClient, error) {
	stream, err := c.cc.NewStream(ctx, &_Netem_serviceDesc.Streams[0], "/netem.Netem/PullImages", opts...)
	if err != nil {
		return nil, err
	}
	x := &netemPullImagesClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Netem_PullImagesClient interface {
	Recv() (*PullSrvMsg, error)
	grpc.ClientStream
}

type netemPullImagesClient struct {
	grpc.ClientStream
}

func (x *netemPullImagesClient) Recv() (*PullSrvMsg, error) {
	m := new(PullSrvMsg)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *netemClient) Clean(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*AckResponse, error) {
	out := new(AckResponse)
	err := c.cc.Invoke(ctx, "/netem.Netem/Clean", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *netemClient) ProjectGetMany(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*PrjListResponse, error) {
	out := new(PrjListResponse)
	err := c.cc.Invoke(ctx, "/netem.Netem/ProjectGetMany", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *netemClient) ProjectOpen(ctx context.Context, in *OpenRequest, opts ...grpc.CallOption) (*PrjOpenResponse, error) {
	out := new(PrjOpenResponse)
	err := c.cc.Invoke(ctx, "/netem.Netem/ProjectOpen", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *netemClient) ProjectClose(ctx context.Context, in *ProjectRequest, opts ...grpc.CallOption) (Netem_ProjectCloseClient, error) {
	stream, err := c.cc.NewStream(ctx, &_Netem_serviceDesc.Streams[1], "/netem.Netem/ProjectClose", opts...)
	if err != nil {
		return nil, err
	}
	x := &netemProjectCloseClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Netem_ProjectCloseClient interface {
	Recv() (*ProjectCloseMsg, error)
	grpc.ClientStream
}

type netemProjectCloseClient struct {
	grpc.ClientStream
}

func (x *netemProjectCloseClient) Recv() (*ProjectCloseMsg, error) {
	m := new(ProjectCloseMsg)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *netemClient) ProjectSave(ctx context.Context, in *ProjectRequest, opts ...grpc.CallOption) (Netem_ProjectSaveClient, error) {
	stream, err := c.cc.NewStream(ctx, &_Netem_serviceDesc.Streams[2], "/netem.Netem/ProjectSave", opts...)
	if err != nil {
		return nil, err
	}
	x := &netemProjectSaveClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Netem_ProjectSaveClient interface {
	Recv() (*ProjectSaveMsg, error)
	grpc.ClientStream
}

type netemProjectSaveClient struct {
	grpc.ClientStream
}

func (x *netemProjectSaveClient) Recv() (*ProjectSaveMsg, error) {
	m := new(ProjectSaveMsg)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *netemClient) ProjectGetNodeConfigs(ctx context.Context, in *ProjectRequest, opts ...grpc.CallOption) (*FileResponse, error) {
	out := new(FileResponse)
	err := c.cc.Invoke(ctx, "/netem.Netem/ProjectGetNodeConfigs", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *netemClient) ProjectGetStatus(ctx context.Context, in *ProjectRequest, opts ...grpc.CallOption) (*StatusResponse, error) {
	out := new(StatusResponse)
	err := c.cc.Invoke(ctx, "/netem.Netem/ProjectGetStatus", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *netemClient) ReadNetworkFile(ctx context.Context, in *ProjectRequest, opts ...grpc.CallOption) (*FileResponse, error) {
	out := new(FileResponse)
	err := c.cc.Invoke(ctx, "/netem.Netem/ReadNetworkFile", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *netemClient) WriteNetworkFile(ctx context.Context, in *WNetworkRequest, opts ...grpc.CallOption) (*AckResponse, error) {
	out := new(AckResponse)
	err := c.cc.Invoke(ctx, "/netem.Netem/WriteNetworkFile", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *netemClient) Check(ctx context.Context, in *ProjectRequest, opts ...grpc.CallOption) (*AckResponse, error) {
	out := new(AckResponse)
	err := c.cc.Invoke(ctx, "/netem.Netem/Check", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *netemClient) TopologyReload(ctx context.Context, in *ProjectRequest, opts ...grpc.CallOption) (Netem_TopologyReloadClient, error) {
	stream, err := c.cc.NewStream(ctx, &_Netem_serviceDesc.Streams[3], "/netem.Netem/TopologyReload", opts...)
	if err != nil {
		return nil, err
	}
	x := &netemTopologyReloadClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Netem_TopologyReloadClient interface {
	Recv() (*TopologyRunMsg, error)
	grpc.ClientStream
}

type netemTopologyReloadClient struct {
	grpc.ClientStream
}

func (x *netemTopologyReloadClient) Recv() (*TopologyRunMsg, error) {
	m := new(TopologyRunMsg)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *netemClient) TopologyRun(ctx context.Context, in *ProjectRequest, opts ...grpc.CallOption) (Netem_TopologyRunClient, error) {
	stream, err := c.cc.NewStream(ctx, &_Netem_serviceDesc.Streams[4], "/netem.Netem/TopologyRun", opts...)
	if err != nil {
		return nil, err
	}
	x := &netemTopologyRunClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Netem_TopologyRunClient interface {
	Recv() (*TopologyRunMsg, error)
	grpc.ClientStream
}

type netemTopologyRunClient struct {
	grpc.ClientStream
}

func (x *netemTopologyRunClient) Recv() (*TopologyRunMsg, error) {
	m := new(TopologyRunMsg)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *netemClient) TopologyStartAll(ctx context.Context, in *ProjectRequest, opts ...grpc.CallOption) (*AckResponse, error) {
	out := new(AckResponse)
	err := c.cc.Invoke(ctx, "/netem.Netem/TopologyStartAll", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *netemClient) TopologyStopAll(ctx context.Context, in *ProjectRequest, opts ...grpc.CallOption) (*AckResponse, error) {
	out := new(AckResponse)
	err := c.cc.Invoke(ctx, "/netem.Netem/TopologyStopAll", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *netemClient) ReadConfigFiles(ctx context.Context, in *NodeRequest, opts ...grpc.CallOption) (*ConfigFilesResponse, error) {
	out := new(ConfigFilesResponse)
	err := c.cc.Invoke(ctx, "/netem.Netem/ReadConfigFiles", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *netemClient) CanRunConsole(ctx context.Context, in *NodeRequest, opts ...grpc.CallOption) (*AckResponse, error) {
	out := new(AckResponse)
	err := c.cc.Invoke(ctx, "/netem.Netem/CanRunConsole", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *netemClient) Console(ctx context.Context, opts ...grpc.CallOption) (Netem_ConsoleClient, error) {
	stream, err := c.cc.NewStream(ctx, &_Netem_serviceDesc.Streams[5], "/netem.Netem/Console", opts...)
	if err != nil {
		return nil, err
	}
	x := &netemConsoleClient{stream}
	return x, nil
}

type Netem_ConsoleClient interface {
	Send(*ConsoleCltMsg) error
	Recv() (*ConsoleSrvMsg, error)
	grpc.ClientStream
}

type netemConsoleClient struct {
	grpc.ClientStream
}

func (x *netemConsoleClient) Send(m *ConsoleCltMsg) error {
	return x.ClientStream.SendMsg(m)
}

func (x *netemConsoleClient) Recv() (*ConsoleSrvMsg, error) {
	m := new(ConsoleSrvMsg)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *netemClient) Start(ctx context.Context, in *NodeRequest, opts ...grpc.CallOption) (*AckResponse, error) {
	out := new(AckResponse)
	err := c.cc.Invoke(ctx, "/netem.Netem/Start", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *netemClient) Stop(ctx context.Context, in *NodeRequest, opts ...grpc.CallOption) (*AckResponse, error) {
	out := new(AckResponse)
	err := c.cc.Invoke(ctx, "/netem.Netem/Stop", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *netemClient) Restart(ctx context.Context, in *NodeRequest, opts ...grpc.CallOption) (*AckResponse, error) {
	out := new(AckResponse)
	err := c.cc.Invoke(ctx, "/netem.Netem/Restart", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *netemClient) SetIfState(ctx context.Context, in *NodeIfStateRequest, opts ...grpc.CallOption) (*AckResponse, error) {
	out := new(AckResponse)
	err := c.cc.Invoke(ctx, "/netem.Netem/SetIfState", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *netemClient) Capture(ctx context.Context, in *NodeInterfaceRequest, opts ...grpc.CallOption) (Netem_CaptureClient, error) {
	stream, err := c.cc.NewStream(ctx, &_Netem_serviceDesc.Streams[6], "/netem.Netem/Capture", opts...)
	if err != nil {
		return nil, err
	}
	x := &netemCaptureClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Netem_CaptureClient interface {
	Recv() (*CaptureSrvMsg, error)
	grpc.ClientStream
}

type netemCaptureClient struct {
	grpc.ClientStream
}

func (x *netemCaptureClient) Recv() (*CaptureSrvMsg, error) {
	m := new(CaptureSrvMsg)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *netemClient) CopyFrom(ctx context.Context, in *CopyMsg, opts ...grpc.CallOption) (Netem_CopyFromClient, error) {
	stream, err := c.cc.NewStream(ctx, &_Netem_serviceDesc.Streams[7], "/netem.Netem/CopyFrom", opts...)
	if err != nil {
		return nil, err
	}
	x := &netemCopyFromClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Netem_CopyFromClient interface {
	Recv() (*CopyMsg, error)
	grpc.ClientStream
}

type netemCopyFromClient struct {
	grpc.ClientStream
}

func (x *netemCopyFromClient) Recv() (*CopyMsg, error) {
	m := new(CopyMsg)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *netemClient) CopyTo(ctx context.Context, opts ...grpc.CallOption) (Netem_CopyToClient, error) {
	stream, err := c.cc.NewStream(ctx, &_Netem_serviceDesc.Streams[8], "/netem.Netem/CopyTo", opts...)
	if err != nil {
		return nil, err
	}
	x := &netemCopyToClient{stream}
	return x, nil
}

type Netem_CopyToClient interface {
	Send(*CopyMsg) error
	CloseAndRecv() (*AckResponse, error)
	grpc.ClientStream
}

type netemCopyToClient struct {
	grpc.ClientStream
}

func (x *netemCopyToClient) Send(m *CopyMsg) error {
	return x.ClientStream.SendMsg(m)
}

func (x *netemCopyToClient) CloseAndRecv() (*AckResponse, error) {
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	m := new(AckResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *netemClient) LinkUpdate(ctx context.Context, in *LinkRequest, opts ...grpc.CallOption) (*AckResponse, error) {
	out := new(AckResponse)
	err := c.cc.Invoke(ctx, "/netem.Netem/LinkUpdate", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// NetemServer is the server API for Netem service.
// All implementations must embed UnimplementedNetemServer
// for forward compatibility
type NetemServer interface {
	// general action
	GetVersion(context.Context, *emptypb.Empty) (*VersionResponse, error)
	PullImages(*emptypb.Empty, Netem_PullImagesServer) error
	Clean(context.Context, *emptypb.Empty) (*AckResponse, error)
	// Project actions
	ProjectGetMany(context.Context, *emptypb.Empty) (*PrjListResponse, error)
	ProjectOpen(context.Context, *OpenRequest) (*PrjOpenResponse, error)
	ProjectClose(*ProjectRequest, Netem_ProjectCloseServer) error
	ProjectSave(*ProjectRequest, Netem_ProjectSaveServer) error
	ProjectGetNodeConfigs(context.Context, *ProjectRequest) (*FileResponse, error)
	ProjectGetStatus(context.Context, *ProjectRequest) (*StatusResponse, error)
	// Read/Write network topology
	ReadNetworkFile(context.Context, *ProjectRequest) (*FileResponse, error)
	WriteNetworkFile(context.Context, *WNetworkRequest) (*AckResponse, error)
	// topology actions
	Check(context.Context, *ProjectRequest) (*AckResponse, error)
	TopologyReload(*ProjectRequest, Netem_TopologyReloadServer) error
	TopologyRun(*ProjectRequest, Netem_TopologyRunServer) error
	TopologyStartAll(context.Context, *ProjectRequest) (*AckResponse, error)
	TopologyStopAll(context.Context, *ProjectRequest) (*AckResponse, error)
	// Node actions
	ReadConfigFiles(context.Context, *NodeRequest) (*ConfigFilesResponse, error)
	CanRunConsole(context.Context, *NodeRequest) (*AckResponse, error)
	Console(Netem_ConsoleServer) error
	Start(context.Context, *NodeRequest) (*AckResponse, error)
	Stop(context.Context, *NodeRequest) (*AckResponse, error)
	Restart(context.Context, *NodeRequest) (*AckResponse, error)
	SetIfState(context.Context, *NodeIfStateRequest) (*AckResponse, error)
	Capture(*NodeInterfaceRequest, Netem_CaptureServer) error
	CopyFrom(*CopyMsg, Netem_CopyFromServer) error
	CopyTo(Netem_CopyToServer) error
	// Link actions
	LinkUpdate(context.Context, *LinkRequest) (*AckResponse, error)
	mustEmbedUnimplementedNetemServer()
}

// UnimplementedNetemServer must be embedded to have forward compatible implementations.
type UnimplementedNetemServer struct {
}

func (UnimplementedNetemServer) GetVersion(context.Context, *emptypb.Empty) (*VersionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetVersion not implemented")
}
func (UnimplementedNetemServer) PullImages(*emptypb.Empty, Netem_PullImagesServer) error {
	return status.Errorf(codes.Unimplemented, "method PullImages not implemented")
}
func (UnimplementedNetemServer) Clean(context.Context, *emptypb.Empty) (*AckResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Clean not implemented")
}
func (UnimplementedNetemServer) ProjectGetMany(context.Context, *emptypb.Empty) (*PrjListResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ProjectGetMany not implemented")
}
func (UnimplementedNetemServer) ProjectOpen(context.Context, *OpenRequest) (*PrjOpenResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ProjectOpen not implemented")
}
func (UnimplementedNetemServer) ProjectClose(*ProjectRequest, Netem_ProjectCloseServer) error {
	return status.Errorf(codes.Unimplemented, "method ProjectClose not implemented")
}
func (UnimplementedNetemServer) ProjectSave(*ProjectRequest, Netem_ProjectSaveServer) error {
	return status.Errorf(codes.Unimplemented, "method ProjectSave not implemented")
}
func (UnimplementedNetemServer) ProjectGetNodeConfigs(context.Context, *ProjectRequest) (*FileResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ProjectGetNodeConfigs not implemented")
}
func (UnimplementedNetemServer) ProjectGetStatus(context.Context, *ProjectRequest) (*StatusResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ProjectGetStatus not implemented")
}
func (UnimplementedNetemServer) ReadNetworkFile(context.Context, *ProjectRequest) (*FileResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ReadNetworkFile not implemented")
}
func (UnimplementedNetemServer) WriteNetworkFile(context.Context, *WNetworkRequest) (*AckResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method WriteNetworkFile not implemented")
}
func (UnimplementedNetemServer) Check(context.Context, *ProjectRequest) (*AckResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Check not implemented")
}
func (UnimplementedNetemServer) TopologyReload(*ProjectRequest, Netem_TopologyReloadServer) error {
	return status.Errorf(codes.Unimplemented, "method TopologyReload not implemented")
}
func (UnimplementedNetemServer) TopologyRun(*ProjectRequest, Netem_TopologyRunServer) error {
	return status.Errorf(codes.Unimplemented, "method TopologyRun not implemented")
}
func (UnimplementedNetemServer) TopologyStartAll(context.Context, *ProjectRequest) (*AckResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TopologyStartAll not implemented")
}
func (UnimplementedNetemServer) TopologyStopAll(context.Context, *ProjectRequest) (*AckResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TopologyStopAll not implemented")
}
func (UnimplementedNetemServer) ReadConfigFiles(context.Context, *NodeRequest) (*ConfigFilesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ReadConfigFiles not implemented")
}
func (UnimplementedNetemServer) CanRunConsole(context.Context, *NodeRequest) (*AckResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CanRunConsole not implemented")
}
func (UnimplementedNetemServer) Console(Netem_ConsoleServer) error {
	return status.Errorf(codes.Unimplemented, "method Console not implemented")
}
func (UnimplementedNetemServer) Start(context.Context, *NodeRequest) (*AckResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Start not implemented")
}
func (UnimplementedNetemServer) Stop(context.Context, *NodeRequest) (*AckResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Stop not implemented")
}
func (UnimplementedNetemServer) Restart(context.Context, *NodeRequest) (*AckResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Restart not implemented")
}
func (UnimplementedNetemServer) SetIfState(context.Context, *NodeIfStateRequest) (*AckResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetIfState not implemented")
}
func (UnimplementedNetemServer) Capture(*NodeInterfaceRequest, Netem_CaptureServer) error {
	return status.Errorf(codes.Unimplemented, "method Capture not implemented")
}
func (UnimplementedNetemServer) CopyFrom(*CopyMsg, Netem_CopyFromServer) error {
	return status.Errorf(codes.Unimplemented, "method CopyFrom not implemented")
}
func (UnimplementedNetemServer) CopyTo(Netem_CopyToServer) error {
	return status.Errorf(codes.Unimplemented, "method CopyTo not implemented")
}
func (UnimplementedNetemServer) LinkUpdate(context.Context, *LinkRequest) (*AckResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method LinkUpdate not implemented")
}
func (UnimplementedNetemServer) mustEmbedUnimplementedNetemServer() {}

// UnsafeNetemServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to NetemServer will
// result in compilation errors.
type UnsafeNetemServer interface {
	mustEmbedUnimplementedNetemServer()
}

func RegisterNetemServer(s *grpc.Server, srv NetemServer) {
	s.RegisterService(&_Netem_serviceDesc, srv)
}

func _Netem_GetVersion_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NetemServer).GetVersion(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/netem.Netem/GetVersion",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NetemServer).GetVersion(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Netem_PullImages_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(emptypb.Empty)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(NetemServer).PullImages(m, &netemPullImagesServer{stream})
}

type Netem_PullImagesServer interface {
	Send(*PullSrvMsg) error
	grpc.ServerStream
}

type netemPullImagesServer struct {
	grpc.ServerStream
}

func (x *netemPullImagesServer) Send(m *PullSrvMsg) error {
	return x.ServerStream.SendMsg(m)
}

func _Netem_Clean_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NetemServer).Clean(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/netem.Netem/Clean",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NetemServer).Clean(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Netem_ProjectGetMany_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NetemServer).ProjectGetMany(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/netem.Netem/ProjectGetMany",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NetemServer).ProjectGetMany(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Netem_ProjectOpen_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(OpenRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NetemServer).ProjectOpen(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/netem.Netem/ProjectOpen",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NetemServer).ProjectOpen(ctx, req.(*OpenRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Netem_ProjectClose_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(ProjectRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(NetemServer).ProjectClose(m, &netemProjectCloseServer{stream})
}

type Netem_ProjectCloseServer interface {
	Send(*ProjectCloseMsg) error
	grpc.ServerStream
}

type netemProjectCloseServer struct {
	grpc.ServerStream
}

func (x *netemProjectCloseServer) Send(m *ProjectCloseMsg) error {
	return x.ServerStream.SendMsg(m)
}

func _Netem_ProjectSave_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(ProjectRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(NetemServer).ProjectSave(m, &netemProjectSaveServer{stream})
}

type Netem_ProjectSaveServer interface {
	Send(*ProjectSaveMsg) error
	grpc.ServerStream
}

type netemProjectSaveServer struct {
	grpc.ServerStream
}

func (x *netemProjectSaveServer) Send(m *ProjectSaveMsg) error {
	return x.ServerStream.SendMsg(m)
}

func _Netem_ProjectGetNodeConfigs_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ProjectRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NetemServer).ProjectGetNodeConfigs(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/netem.Netem/ProjectGetNodeConfigs",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NetemServer).ProjectGetNodeConfigs(ctx, req.(*ProjectRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Netem_ProjectGetStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ProjectRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NetemServer).ProjectGetStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/netem.Netem/ProjectGetStatus",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NetemServer).ProjectGetStatus(ctx, req.(*ProjectRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Netem_ReadNetworkFile_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ProjectRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NetemServer).ReadNetworkFile(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/netem.Netem/ReadNetworkFile",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NetemServer).ReadNetworkFile(ctx, req.(*ProjectRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Netem_WriteNetworkFile_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(WNetworkRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NetemServer).WriteNetworkFile(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/netem.Netem/WriteNetworkFile",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NetemServer).WriteNetworkFile(ctx, req.(*WNetworkRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Netem_Check_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ProjectRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NetemServer).Check(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/netem.Netem/Check",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NetemServer).Check(ctx, req.(*ProjectRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Netem_TopologyReload_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(ProjectRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(NetemServer).TopologyReload(m, &netemTopologyReloadServer{stream})
}

type Netem_TopologyReloadServer interface {
	Send(*TopologyRunMsg) error
	grpc.ServerStream
}

type netemTopologyReloadServer struct {
	grpc.ServerStream
}

func (x *netemTopologyReloadServer) Send(m *TopologyRunMsg) error {
	return x.ServerStream.SendMsg(m)
}

func _Netem_TopologyRun_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(ProjectRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(NetemServer).TopologyRun(m, &netemTopologyRunServer{stream})
}

type Netem_TopologyRunServer interface {
	Send(*TopologyRunMsg) error
	grpc.ServerStream
}

type netemTopologyRunServer struct {
	grpc.ServerStream
}

func (x *netemTopologyRunServer) Send(m *TopologyRunMsg) error {
	return x.ServerStream.SendMsg(m)
}

func _Netem_TopologyStartAll_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ProjectRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NetemServer).TopologyStartAll(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/netem.Netem/TopologyStartAll",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NetemServer).TopologyStartAll(ctx, req.(*ProjectRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Netem_TopologyStopAll_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ProjectRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NetemServer).TopologyStopAll(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/netem.Netem/TopologyStopAll",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NetemServer).TopologyStopAll(ctx, req.(*ProjectRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Netem_ReadConfigFiles_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NodeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NetemServer).ReadConfigFiles(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/netem.Netem/ReadConfigFiles",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NetemServer).ReadConfigFiles(ctx, req.(*NodeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Netem_CanRunConsole_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NodeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NetemServer).CanRunConsole(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/netem.Netem/CanRunConsole",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NetemServer).CanRunConsole(ctx, req.(*NodeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Netem_Console_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(NetemServer).Console(&netemConsoleServer{stream})
}

type Netem_ConsoleServer interface {
	Send(*ConsoleSrvMsg) error
	Recv() (*ConsoleCltMsg, error)
	grpc.ServerStream
}

type netemConsoleServer struct {
	grpc.ServerStream
}

func (x *netemConsoleServer) Send(m *ConsoleSrvMsg) error {
	return x.ServerStream.SendMsg(m)
}

func (x *netemConsoleServer) Recv() (*ConsoleCltMsg, error) {
	m := new(ConsoleCltMsg)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _Netem_Start_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NodeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NetemServer).Start(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/netem.Netem/Start",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NetemServer).Start(ctx, req.(*NodeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Netem_Stop_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NodeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NetemServer).Stop(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/netem.Netem/Stop",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NetemServer).Stop(ctx, req.(*NodeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Netem_Restart_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NodeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NetemServer).Restart(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/netem.Netem/Restart",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NetemServer).Restart(ctx, req.(*NodeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Netem_SetIfState_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NodeIfStateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NetemServer).SetIfState(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/netem.Netem/SetIfState",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NetemServer).SetIfState(ctx, req.(*NodeIfStateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Netem_Capture_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(NodeInterfaceRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(NetemServer).Capture(m, &netemCaptureServer{stream})
}

type Netem_CaptureServer interface {
	Send(*CaptureSrvMsg) error
	grpc.ServerStream
}

type netemCaptureServer struct {
	grpc.ServerStream
}

func (x *netemCaptureServer) Send(m *CaptureSrvMsg) error {
	return x.ServerStream.SendMsg(m)
}

func _Netem_CopyFrom_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(CopyMsg)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(NetemServer).CopyFrom(m, &netemCopyFromServer{stream})
}

type Netem_CopyFromServer interface {
	Send(*CopyMsg) error
	grpc.ServerStream
}

type netemCopyFromServer struct {
	grpc.ServerStream
}

func (x *netemCopyFromServer) Send(m *CopyMsg) error {
	return x.ServerStream.SendMsg(m)
}

func _Netem_CopyTo_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(NetemServer).CopyTo(&netemCopyToServer{stream})
}

type Netem_CopyToServer interface {
	SendAndClose(*AckResponse) error
	Recv() (*CopyMsg, error)
	grpc.ServerStream
}

type netemCopyToServer struct {
	grpc.ServerStream
}

func (x *netemCopyToServer) SendAndClose(m *AckResponse) error {
	return x.ServerStream.SendMsg(m)
}

func (x *netemCopyToServer) Recv() (*CopyMsg, error) {
	m := new(CopyMsg)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _Netem_LinkUpdate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LinkRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NetemServer).LinkUpdate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/netem.Netem/LinkUpdate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NetemServer).LinkUpdate(ctx, req.(*LinkRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _Netem_serviceDesc = grpc.ServiceDesc{
	ServiceName: "netem.Netem",
	HandlerType: (*NetemServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetVersion",
			Handler:    _Netem_GetVersion_Handler,
		},
		{
			MethodName: "Clean",
			Handler:    _Netem_Clean_Handler,
		},
		{
			MethodName: "ProjectGetMany",
			Handler:    _Netem_ProjectGetMany_Handler,
		},
		{
			MethodName: "ProjectOpen",
			Handler:    _Netem_ProjectOpen_Handler,
		},
		{
			MethodName: "ProjectGetNodeConfigs",
			Handler:    _Netem_ProjectGetNodeConfigs_Handler,
		},
		{
			MethodName: "ProjectGetStatus",
			Handler:    _Netem_ProjectGetStatus_Handler,
		},
		{
			MethodName: "ReadNetworkFile",
			Handler:    _Netem_ReadNetworkFile_Handler,
		},
		{
			MethodName: "WriteNetworkFile",
			Handler:    _Netem_WriteNetworkFile_Handler,
		},
		{
			MethodName: "Check",
			Handler:    _Netem_Check_Handler,
		},
		{
			MethodName: "TopologyStartAll",
			Handler:    _Netem_TopologyStartAll_Handler,
		},
		{
			MethodName: "TopologyStopAll",
			Handler:    _Netem_TopologyStopAll_Handler,
		},
		{
			MethodName: "ReadConfigFiles",
			Handler:    _Netem_ReadConfigFiles_Handler,
		},
		{
			MethodName: "CanRunConsole",
			Handler:    _Netem_CanRunConsole_Handler,
		},
		{
			MethodName: "Start",
			Handler:    _Netem_Start_Handler,
		},
		{
			MethodName: "Stop",
			Handler:    _Netem_Stop_Handler,
		},
		{
			MethodName: "Restart",
			Handler:    _Netem_Restart_Handler,
		},
		{
			MethodName: "SetIfState",
			Handler:    _Netem_SetIfState_Handler,
		},
		{
			MethodName: "LinkUpdate",
			Handler:    _Netem_LinkUpdate_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "PullImages",
			Handler:       _Netem_PullImages_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "ProjectClose",
			Handler:       _Netem_ProjectClose_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "ProjectSave",
			Handler:       _Netem_ProjectSave_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "TopologyReload",
			Handler:       _Netem_TopologyReload_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "TopologyRun",
			Handler:       _Netem_TopologyRun_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "Console",
			Handler:       _Netem_Console_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
		{
			StreamName:    "Capture",
			Handler:       _Netem_Capture_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "CopyFrom",
			Handler:       _Netem_CopyFrom_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "CopyTo",
			Handler:       _Netem_CopyTo_Handler,
			ClientStreams: true,
		},
	},
	Metadata: "internal/proto/netem.proto",
}

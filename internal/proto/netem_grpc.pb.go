// Code generated by protoc-gen-go-grpc. DO NOT EDIT.

package proto

import (
	context "context"
	empty "github.com/golang/protobuf/ptypes/empty"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

// NetemClient is the client API for Netem service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type NetemClient interface {
	// general action
	GetVersion(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*VersionResponse, error)
	PullImages(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (Netem_PullImagesClient, error)
	Clean(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*AckResponse, error)
	// Project actions
	GetProjects(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*PrjListResponse, error)
	OpenProject(ctx context.Context, in *OpenRequest, opts ...grpc.CallOption) (*PrjOpenResponse, error)
	CloseProject(ctx context.Context, in *ProjectRequest, opts ...grpc.CallOption) (*AckResponse, error)
	SaveProject(ctx context.Context, in *ProjectRequest, opts ...grpc.CallOption) (*FileResponse, error)
	GetProjectStatus(ctx context.Context, in *ProjectRequest, opts ...grpc.CallOption) (*StatusResponse, error)
	// Read/Write network topology
	ReadNetworkFile(ctx context.Context, in *ProjectRequest, opts ...grpc.CallOption) (*FileResponse, error)
	WriteNetworkFile(ctx context.Context, in *WNetworkRequest, opts ...grpc.CallOption) (*AckResponse, error)
	// topology actions
	Check(ctx context.Context, in *ProjectRequest, opts ...grpc.CallOption) (*AckResponse, error)
	Reload(ctx context.Context, in *ProjectRequest, opts ...grpc.CallOption) (*AckResponse, error)
	Run(ctx context.Context, in *ProjectRequest, opts ...grpc.CallOption) (*AckResponse, error)
	// Node actions
	CanRunConsole(ctx context.Context, in *NodeRequest, opts ...grpc.CallOption) (*AckResponse, error)
	Console(ctx context.Context, opts ...grpc.CallOption) (Netem_ConsoleClient, error)
	Start(ctx context.Context, in *NodeRequest, opts ...grpc.CallOption) (*AckResponse, error)
	Stop(ctx context.Context, in *NodeRequest, opts ...grpc.CallOption) (*AckResponse, error)
	Restart(ctx context.Context, in *NodeRequest, opts ...grpc.CallOption) (*AckResponse, error)
	SetIfState(ctx context.Context, in *NodeIfStateRequest, opts ...grpc.CallOption) (*AckResponse, error)
	Capture(ctx context.Context, in *NodeInterfaceRequest, opts ...grpc.CallOption) (Netem_CaptureClient, error)
}

type netemClient struct {
	cc grpc.ClientConnInterface
}

func NewNetemClient(cc grpc.ClientConnInterface) NetemClient {
	return &netemClient{cc}
}

func (c *netemClient) GetVersion(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*VersionResponse, error) {
	out := new(VersionResponse)
	err := c.cc.Invoke(ctx, "/netem.Netem/GetVersion", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *netemClient) PullImages(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (Netem_PullImagesClient, error) {
	stream, err := c.cc.NewStream(ctx, &Netem_ServiceDesc.Streams[0], "/netem.Netem/PullImages", opts...)
	if err != nil {
		return nil, err
	}
	x := &netemPullImagesClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Netem_PullImagesClient interface {
	Recv() (*PullSrvMsg, error)
	grpc.ClientStream
}

type netemPullImagesClient struct {
	grpc.ClientStream
}

func (x *netemPullImagesClient) Recv() (*PullSrvMsg, error) {
	m := new(PullSrvMsg)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *netemClient) Clean(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*AckResponse, error) {
	out := new(AckResponse)
	err := c.cc.Invoke(ctx, "/netem.Netem/Clean", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *netemClient) GetProjects(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*PrjListResponse, error) {
	out := new(PrjListResponse)
	err := c.cc.Invoke(ctx, "/netem.Netem/GetProjects", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *netemClient) OpenProject(ctx context.Context, in *OpenRequest, opts ...grpc.CallOption) (*PrjOpenResponse, error) {
	out := new(PrjOpenResponse)
	err := c.cc.Invoke(ctx, "/netem.Netem/OpenProject", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *netemClient) CloseProject(ctx context.Context, in *ProjectRequest, opts ...grpc.CallOption) (*AckResponse, error) {
	out := new(AckResponse)
	err := c.cc.Invoke(ctx, "/netem.Netem/CloseProject", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *netemClient) SaveProject(ctx context.Context, in *ProjectRequest, opts ...grpc.CallOption) (*FileResponse, error) {
	out := new(FileResponse)
	err := c.cc.Invoke(ctx, "/netem.Netem/SaveProject", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *netemClient) GetProjectStatus(ctx context.Context, in *ProjectRequest, opts ...grpc.CallOption) (*StatusResponse, error) {
	out := new(StatusResponse)
	err := c.cc.Invoke(ctx, "/netem.Netem/GetProjectStatus", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *netemClient) ReadNetworkFile(ctx context.Context, in *ProjectRequest, opts ...grpc.CallOption) (*FileResponse, error) {
	out := new(FileResponse)
	err := c.cc.Invoke(ctx, "/netem.Netem/ReadNetworkFile", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *netemClient) WriteNetworkFile(ctx context.Context, in *WNetworkRequest, opts ...grpc.CallOption) (*AckResponse, error) {
	out := new(AckResponse)
	err := c.cc.Invoke(ctx, "/netem.Netem/WriteNetworkFile", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *netemClient) Check(ctx context.Context, in *ProjectRequest, opts ...grpc.CallOption) (*AckResponse, error) {
	out := new(AckResponse)
	err := c.cc.Invoke(ctx, "/netem.Netem/Check", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *netemClient) Reload(ctx context.Context, in *ProjectRequest, opts ...grpc.CallOption) (*AckResponse, error) {
	out := new(AckResponse)
	err := c.cc.Invoke(ctx, "/netem.Netem/Reload", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *netemClient) Run(ctx context.Context, in *ProjectRequest, opts ...grpc.CallOption) (*AckResponse, error) {
	out := new(AckResponse)
	err := c.cc.Invoke(ctx, "/netem.Netem/Run", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *netemClient) CanRunConsole(ctx context.Context, in *NodeRequest, opts ...grpc.CallOption) (*AckResponse, error) {
	out := new(AckResponse)
	err := c.cc.Invoke(ctx, "/netem.Netem/CanRunConsole", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *netemClient) Console(ctx context.Context, opts ...grpc.CallOption) (Netem_ConsoleClient, error) {
	stream, err := c.cc.NewStream(ctx, &Netem_ServiceDesc.Streams[1], "/netem.Netem/Console", opts...)
	if err != nil {
		return nil, err
	}
	x := &netemConsoleClient{stream}
	return x, nil
}

type Netem_ConsoleClient interface {
	Send(*ConsoleCltMsg) error
	Recv() (*ConsoleSrvMsg, error)
	grpc.ClientStream
}

type netemConsoleClient struct {
	grpc.ClientStream
}

func (x *netemConsoleClient) Send(m *ConsoleCltMsg) error {
	return x.ClientStream.SendMsg(m)
}

func (x *netemConsoleClient) Recv() (*ConsoleSrvMsg, error) {
	m := new(ConsoleSrvMsg)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *netemClient) Start(ctx context.Context, in *NodeRequest, opts ...grpc.CallOption) (*AckResponse, error) {
	out := new(AckResponse)
	err := c.cc.Invoke(ctx, "/netem.Netem/Start", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *netemClient) Stop(ctx context.Context, in *NodeRequest, opts ...grpc.CallOption) (*AckResponse, error) {
	out := new(AckResponse)
	err := c.cc.Invoke(ctx, "/netem.Netem/Stop", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *netemClient) Restart(ctx context.Context, in *NodeRequest, opts ...grpc.CallOption) (*AckResponse, error) {
	out := new(AckResponse)
	err := c.cc.Invoke(ctx, "/netem.Netem/Restart", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *netemClient) SetIfState(ctx context.Context, in *NodeIfStateRequest, opts ...grpc.CallOption) (*AckResponse, error) {
	out := new(AckResponse)
	err := c.cc.Invoke(ctx, "/netem.Netem/SetIfState", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *netemClient) Capture(ctx context.Context, in *NodeInterfaceRequest, opts ...grpc.CallOption) (Netem_CaptureClient, error) {
	stream, err := c.cc.NewStream(ctx, &Netem_ServiceDesc.Streams[2], "/netem.Netem/Capture", opts...)
	if err != nil {
		return nil, err
	}
	x := &netemCaptureClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Netem_CaptureClient interface {
	Recv() (*CaptureSrvMsg, error)
	grpc.ClientStream
}

type netemCaptureClient struct {
	grpc.ClientStream
}

func (x *netemCaptureClient) Recv() (*CaptureSrvMsg, error) {
	m := new(CaptureSrvMsg)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// NetemServer is the server API for Netem service.
// All implementations must embed UnimplementedNetemServer
// for forward compatibility
type NetemServer interface {
	// general action
	GetVersion(context.Context, *empty.Empty) (*VersionResponse, error)
	PullImages(*empty.Empty, Netem_PullImagesServer) error
	Clean(context.Context, *empty.Empty) (*AckResponse, error)
	// Project actions
	GetProjects(context.Context, *empty.Empty) (*PrjListResponse, error)
	OpenProject(context.Context, *OpenRequest) (*PrjOpenResponse, error)
	CloseProject(context.Context, *ProjectRequest) (*AckResponse, error)
	SaveProject(context.Context, *ProjectRequest) (*FileResponse, error)
	GetProjectStatus(context.Context, *ProjectRequest) (*StatusResponse, error)
	// Read/Write network topology
	ReadNetworkFile(context.Context, *ProjectRequest) (*FileResponse, error)
	WriteNetworkFile(context.Context, *WNetworkRequest) (*AckResponse, error)
	// topology actions
	Check(context.Context, *ProjectRequest) (*AckResponse, error)
	Reload(context.Context, *ProjectRequest) (*AckResponse, error)
	Run(context.Context, *ProjectRequest) (*AckResponse, error)
	// Node actions
	CanRunConsole(context.Context, *NodeRequest) (*AckResponse, error)
	Console(Netem_ConsoleServer) error
	Start(context.Context, *NodeRequest) (*AckResponse, error)
	Stop(context.Context, *NodeRequest) (*AckResponse, error)
	Restart(context.Context, *NodeRequest) (*AckResponse, error)
	SetIfState(context.Context, *NodeIfStateRequest) (*AckResponse, error)
	Capture(*NodeInterfaceRequest, Netem_CaptureServer) error
	mustEmbedUnimplementedNetemServer()
}

// UnimplementedNetemServer must be embedded to have forward compatible implementations.
type UnimplementedNetemServer struct {
}

func (UnimplementedNetemServer) GetVersion(context.Context, *empty.Empty) (*VersionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetVersion not implemented")
}
func (UnimplementedNetemServer) PullImages(*empty.Empty, Netem_PullImagesServer) error {
	return status.Errorf(codes.Unimplemented, "method PullImages not implemented")
}
func (UnimplementedNetemServer) Clean(context.Context, *empty.Empty) (*AckResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Clean not implemented")
}
func (UnimplementedNetemServer) GetProjects(context.Context, *empty.Empty) (*PrjListResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetProjects not implemented")
}
func (UnimplementedNetemServer) OpenProject(context.Context, *OpenRequest) (*PrjOpenResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method OpenProject not implemented")
}
func (UnimplementedNetemServer) CloseProject(context.Context, *ProjectRequest) (*AckResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CloseProject not implemented")
}
func (UnimplementedNetemServer) SaveProject(context.Context, *ProjectRequest) (*FileResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SaveProject not implemented")
}
func (UnimplementedNetemServer) GetProjectStatus(context.Context, *ProjectRequest) (*StatusResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetProjectStatus not implemented")
}
func (UnimplementedNetemServer) ReadNetworkFile(context.Context, *ProjectRequest) (*FileResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ReadNetworkFile not implemented")
}
func (UnimplementedNetemServer) WriteNetworkFile(context.Context, *WNetworkRequest) (*AckResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method WriteNetworkFile not implemented")
}
func (UnimplementedNetemServer) Check(context.Context, *ProjectRequest) (*AckResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Check not implemented")
}
func (UnimplementedNetemServer) Reload(context.Context, *ProjectRequest) (*AckResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Reload not implemented")
}
func (UnimplementedNetemServer) Run(context.Context, *ProjectRequest) (*AckResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Run not implemented")
}
func (UnimplementedNetemServer) CanRunConsole(context.Context, *NodeRequest) (*AckResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CanRunConsole not implemented")
}
func (UnimplementedNetemServer) Console(Netem_ConsoleServer) error {
	return status.Errorf(codes.Unimplemented, "method Console not implemented")
}
func (UnimplementedNetemServer) Start(context.Context, *NodeRequest) (*AckResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Start not implemented")
}
func (UnimplementedNetemServer) Stop(context.Context, *NodeRequest) (*AckResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Stop not implemented")
}
func (UnimplementedNetemServer) Restart(context.Context, *NodeRequest) (*AckResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Restart not implemented")
}
func (UnimplementedNetemServer) SetIfState(context.Context, *NodeIfStateRequest) (*AckResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetIfState not implemented")
}
func (UnimplementedNetemServer) Capture(*NodeInterfaceRequest, Netem_CaptureServer) error {
	return status.Errorf(codes.Unimplemented, "method Capture not implemented")
}
func (UnimplementedNetemServer) mustEmbedUnimplementedNetemServer() {}

// UnsafeNetemServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to NetemServer will
// result in compilation errors.
type UnsafeNetemServer interface {
	mustEmbedUnimplementedNetemServer()
}

func RegisterNetemServer(s grpc.ServiceRegistrar, srv NetemServer) {
	s.RegisterService(&Netem_ServiceDesc, srv)
}

func _Netem_GetVersion_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(empty.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NetemServer).GetVersion(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/netem.Netem/GetVersion",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NetemServer).GetVersion(ctx, req.(*empty.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Netem_PullImages_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(empty.Empty)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(NetemServer).PullImages(m, &netemPullImagesServer{stream})
}

type Netem_PullImagesServer interface {
	Send(*PullSrvMsg) error
	grpc.ServerStream
}

type netemPullImagesServer struct {
	grpc.ServerStream
}

func (x *netemPullImagesServer) Send(m *PullSrvMsg) error {
	return x.ServerStream.SendMsg(m)
}

func _Netem_Clean_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(empty.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NetemServer).Clean(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/netem.Netem/Clean",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NetemServer).Clean(ctx, req.(*empty.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Netem_GetProjects_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(empty.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NetemServer).GetProjects(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/netem.Netem/GetProjects",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NetemServer).GetProjects(ctx, req.(*empty.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Netem_OpenProject_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(OpenRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NetemServer).OpenProject(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/netem.Netem/OpenProject",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NetemServer).OpenProject(ctx, req.(*OpenRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Netem_CloseProject_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ProjectRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NetemServer).CloseProject(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/netem.Netem/CloseProject",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NetemServer).CloseProject(ctx, req.(*ProjectRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Netem_SaveProject_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ProjectRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NetemServer).SaveProject(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/netem.Netem/SaveProject",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NetemServer).SaveProject(ctx, req.(*ProjectRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Netem_GetProjectStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ProjectRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NetemServer).GetProjectStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/netem.Netem/GetProjectStatus",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NetemServer).GetProjectStatus(ctx, req.(*ProjectRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Netem_ReadNetworkFile_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ProjectRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NetemServer).ReadNetworkFile(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/netem.Netem/ReadNetworkFile",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NetemServer).ReadNetworkFile(ctx, req.(*ProjectRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Netem_WriteNetworkFile_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(WNetworkRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NetemServer).WriteNetworkFile(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/netem.Netem/WriteNetworkFile",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NetemServer).WriteNetworkFile(ctx, req.(*WNetworkRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Netem_Check_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ProjectRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NetemServer).Check(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/netem.Netem/Check",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NetemServer).Check(ctx, req.(*ProjectRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Netem_Reload_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ProjectRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NetemServer).Reload(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/netem.Netem/Reload",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NetemServer).Reload(ctx, req.(*ProjectRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Netem_Run_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ProjectRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NetemServer).Run(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/netem.Netem/Run",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NetemServer).Run(ctx, req.(*ProjectRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Netem_CanRunConsole_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NodeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NetemServer).CanRunConsole(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/netem.Netem/CanRunConsole",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NetemServer).CanRunConsole(ctx, req.(*NodeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Netem_Console_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(NetemServer).Console(&netemConsoleServer{stream})
}

type Netem_ConsoleServer interface {
	Send(*ConsoleSrvMsg) error
	Recv() (*ConsoleCltMsg, error)
	grpc.ServerStream
}

type netemConsoleServer struct {
	grpc.ServerStream
}

func (x *netemConsoleServer) Send(m *ConsoleSrvMsg) error {
	return x.ServerStream.SendMsg(m)
}

func (x *netemConsoleServer) Recv() (*ConsoleCltMsg, error) {
	m := new(ConsoleCltMsg)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _Netem_Start_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NodeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NetemServer).Start(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/netem.Netem/Start",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NetemServer).Start(ctx, req.(*NodeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Netem_Stop_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NodeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NetemServer).Stop(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/netem.Netem/Stop",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NetemServer).Stop(ctx, req.(*NodeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Netem_Restart_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NodeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NetemServer).Restart(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/netem.Netem/Restart",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NetemServer).Restart(ctx, req.(*NodeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Netem_SetIfState_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NodeIfStateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NetemServer).SetIfState(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/netem.Netem/SetIfState",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NetemServer).SetIfState(ctx, req.(*NodeIfStateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Netem_Capture_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(NodeInterfaceRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(NetemServer).Capture(m, &netemCaptureServer{stream})
}

type Netem_CaptureServer interface {
	Send(*CaptureSrvMsg) error
	grpc.ServerStream
}

type netemCaptureServer struct {
	grpc.ServerStream
}

func (x *netemCaptureServer) Send(m *CaptureSrvMsg) error {
	return x.ServerStream.SendMsg(m)
}

// Netem_ServiceDesc is the grpc.ServiceDesc for Netem service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Netem_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "netem.Netem",
	HandlerType: (*NetemServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetVersion",
			Handler:    _Netem_GetVersion_Handler,
		},
		{
			MethodName: "Clean",
			Handler:    _Netem_Clean_Handler,
		},
		{
			MethodName: "GetProjects",
			Handler:    _Netem_GetProjects_Handler,
		},
		{
			MethodName: "OpenProject",
			Handler:    _Netem_OpenProject_Handler,
		},
		{
			MethodName: "CloseProject",
			Handler:    _Netem_CloseProject_Handler,
		},
		{
			MethodName: "SaveProject",
			Handler:    _Netem_SaveProject_Handler,
		},
		{
			MethodName: "GetProjectStatus",
			Handler:    _Netem_GetProjectStatus_Handler,
		},
		{
			MethodName: "ReadNetworkFile",
			Handler:    _Netem_ReadNetworkFile_Handler,
		},
		{
			MethodName: "WriteNetworkFile",
			Handler:    _Netem_WriteNetworkFile_Handler,
		},
		{
			MethodName: "Check",
			Handler:    _Netem_Check_Handler,
		},
		{
			MethodName: "Reload",
			Handler:    _Netem_Reload_Handler,
		},
		{
			MethodName: "Run",
			Handler:    _Netem_Run_Handler,
		},
		{
			MethodName: "CanRunConsole",
			Handler:    _Netem_CanRunConsole_Handler,
		},
		{
			MethodName: "Start",
			Handler:    _Netem_Start_Handler,
		},
		{
			MethodName: "Stop",
			Handler:    _Netem_Stop_Handler,
		},
		{
			MethodName: "Restart",
			Handler:    _Netem_Restart_Handler,
		},
		{
			MethodName: "SetIfState",
			Handler:    _Netem_SetIfState_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "PullImages",
			Handler:       _Netem_PullImages_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "Console",
			Handler:       _Netem_Console_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
		{
			StreamName:    "Capture",
			Handler:       _Netem_Capture_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "internal/proto/netem.proto",
}

// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.3.0
// - protoc             v4.25.3
// source: internal/proto/netem.proto

package proto

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	emptypb "google.golang.org/protobuf/types/known/emptypb"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

const (
	Netem_ServerGetVersion_FullMethodName      = "/netem.Netem/ServerGetVersion"
	Netem_ServerPullImages_FullMethodName      = "/netem.Netem/ServerPullImages"
	Netem_ServerCleanContainers_FullMethodName = "/netem.Netem/ServerCleanContainers"
	Netem_ProjectGetMany_FullMethodName        = "/netem.Netem/ProjectGetMany"
	Netem_ProjectOpen_FullMethodName           = "/netem.Netem/ProjectOpen"
	Netem_ProjectClose_FullMethodName          = "/netem.Netem/ProjectClose"
	Netem_ProjectSave_FullMethodName           = "/netem.Netem/ProjectSave"
	Netem_ProjectGetNodeConfigs_FullMethodName = "/netem.Netem/ProjectGetNodeConfigs"
	Netem_ProjectGetStatus_FullMethodName      = "/netem.Netem/ProjectGetStatus"
	Netem_ReadNetworkFile_FullMethodName       = "/netem.Netem/ReadNetworkFile"
	Netem_WriteNetworkFile_FullMethodName      = "/netem.Netem/WriteNetworkFile"
	Netem_TopologyCheck_FullMethodName         = "/netem.Netem/TopologyCheck"
	Netem_TopologyReload_FullMethodName        = "/netem.Netem/TopologyReload"
	Netem_TopologyRun_FullMethodName           = "/netem.Netem/TopologyRun"
	Netem_TopologyStartAll_FullMethodName      = "/netem.Netem/TopologyStartAll"
	Netem_TopologyStopAll_FullMethodName       = "/netem.Netem/TopologyStopAll"
	Netem_NodeReadConfigFiles_FullMethodName   = "/netem.Netem/NodeReadConfigFiles"
	Netem_NodeCanRunConsole_FullMethodName     = "/netem.Netem/NodeCanRunConsole"
	Netem_NodeConsole_FullMethodName           = "/netem.Netem/NodeConsole"
	Netem_NodeStart_FullMethodName             = "/netem.Netem/NodeStart"
	Netem_NodeStop_FullMethodName              = "/netem.Netem/NodeStop"
	Netem_NodeRestart_FullMethodName           = "/netem.Netem/NodeRestart"
	Netem_NodeSetIfState_FullMethodName        = "/netem.Netem/NodeSetIfState"
	Netem_NodeCapture_FullMethodName           = "/netem.Netem/NodeCapture"
	Netem_NodeCopyFrom_FullMethodName          = "/netem.Netem/NodeCopyFrom"
	Netem_NodeCopyTo_FullMethodName            = "/netem.Netem/NodeCopyTo"
	Netem_LinkUpdate_FullMethodName            = "/netem.Netem/LinkUpdate"
)

// NetemClient is the client API for Netem service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type NetemClient interface {
	// Server actions
	ServerGetVersion(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*VersionResponse, error)
	ServerPullImages(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (Netem_ServerPullImagesClient, error)
	ServerCleanContainers(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*AckResponse, error)
	// Project actions
	ProjectGetMany(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*PrjListResponse, error)
	ProjectOpen(ctx context.Context, in *OpenRequest, opts ...grpc.CallOption) (*PrjOpenResponse, error)
	ProjectClose(ctx context.Context, in *ProjectRequest, opts ...grpc.CallOption) (Netem_ProjectCloseClient, error)
	ProjectSave(ctx context.Context, in *ProjectRequest, opts ...grpc.CallOption) (Netem_ProjectSaveClient, error)
	ProjectGetNodeConfigs(ctx context.Context, in *ProjectRequest, opts ...grpc.CallOption) (*FileResponse, error)
	ProjectGetStatus(ctx context.Context, in *ProjectRequest, opts ...grpc.CallOption) (*StatusResponse, error)
	// Read/Write network topology
	ReadNetworkFile(ctx context.Context, in *ProjectRequest, opts ...grpc.CallOption) (*FileResponse, error)
	WriteNetworkFile(ctx context.Context, in *WNetworkRequest, opts ...grpc.CallOption) (*AckResponse, error)
	// topology actions
	TopologyCheck(ctx context.Context, in *ProjectRequest, opts ...grpc.CallOption) (*AckResponse, error)
	TopologyReload(ctx context.Context, in *ProjectRequest, opts ...grpc.CallOption) (Netem_TopologyReloadClient, error)
	TopologyRun(ctx context.Context, in *ProjectRequest, opts ...grpc.CallOption) (Netem_TopologyRunClient, error)
	TopologyStartAll(ctx context.Context, in *ProjectRequest, opts ...grpc.CallOption) (*AckResponse, error)
	TopologyStopAll(ctx context.Context, in *ProjectRequest, opts ...grpc.CallOption) (*AckResponse, error)
	// Node actions
	NodeReadConfigFiles(ctx context.Context, in *NodeRequest, opts ...grpc.CallOption) (*ConfigFilesResponse, error)
	NodeCanRunConsole(ctx context.Context, in *NodeRequest, opts ...grpc.CallOption) (*AckResponse, error)
	NodeConsole(ctx context.Context, opts ...grpc.CallOption) (Netem_NodeConsoleClient, error)
	NodeStart(ctx context.Context, in *NodeRequest, opts ...grpc.CallOption) (*AckResponse, error)
	NodeStop(ctx context.Context, in *NodeRequest, opts ...grpc.CallOption) (*AckResponse, error)
	NodeRestart(ctx context.Context, in *NodeRequest, opts ...grpc.CallOption) (*AckResponse, error)
	NodeSetIfState(ctx context.Context, in *NodeIfStateRequest, opts ...grpc.CallOption) (*AckResponse, error)
	NodeCapture(ctx context.Context, in *NodeInterfaceRequest, opts ...grpc.CallOption) (Netem_NodeCaptureClient, error)
	NodeCopyFrom(ctx context.Context, in *CopyMsg, opts ...grpc.CallOption) (Netem_NodeCopyFromClient, error)
	NodeCopyTo(ctx context.Context, opts ...grpc.CallOption) (Netem_NodeCopyToClient, error)
	// Link actions
	LinkUpdate(ctx context.Context, in *LinkRequest, opts ...grpc.CallOption) (*AckResponse, error)
}

type netemClient struct {
	cc grpc.ClientConnInterface
}

func NewNetemClient(cc grpc.ClientConnInterface) NetemClient {
	return &netemClient{cc}
}

func (c *netemClient) ServerGetVersion(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*VersionResponse, error) {
	out := new(VersionResponse)
	err := c.cc.Invoke(ctx, Netem_ServerGetVersion_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *netemClient) ServerPullImages(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (Netem_ServerPullImagesClient, error) {
	stream, err := c.cc.NewStream(ctx, &Netem_ServiceDesc.Streams[0], Netem_ServerPullImages_FullMethodName, opts...)
	if err != nil {
		return nil, err
	}
	x := &netemServerPullImagesClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Netem_ServerPullImagesClient interface {
	Recv() (*PullSrvMsg, error)
	grpc.ClientStream
}

type netemServerPullImagesClient struct {
	grpc.ClientStream
}

func (x *netemServerPullImagesClient) Recv() (*PullSrvMsg, error) {
	m := new(PullSrvMsg)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *netemClient) ServerCleanContainers(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*AckResponse, error) {
	out := new(AckResponse)
	err := c.cc.Invoke(ctx, Netem_ServerCleanContainers_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *netemClient) ProjectGetMany(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*PrjListResponse, error) {
	out := new(PrjListResponse)
	err := c.cc.Invoke(ctx, Netem_ProjectGetMany_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *netemClient) ProjectOpen(ctx context.Context, in *OpenRequest, opts ...grpc.CallOption) (*PrjOpenResponse, error) {
	out := new(PrjOpenResponse)
	err := c.cc.Invoke(ctx, Netem_ProjectOpen_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *netemClient) ProjectClose(ctx context.Context, in *ProjectRequest, opts ...grpc.CallOption) (Netem_ProjectCloseClient, error) {
	stream, err := c.cc.NewStream(ctx, &Netem_ServiceDesc.Streams[1], Netem_ProjectClose_FullMethodName, opts...)
	if err != nil {
		return nil, err
	}
	x := &netemProjectCloseClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Netem_ProjectCloseClient interface {
	Recv() (*ProjectCloseMsg, error)
	grpc.ClientStream
}

type netemProjectCloseClient struct {
	grpc.ClientStream
}

func (x *netemProjectCloseClient) Recv() (*ProjectCloseMsg, error) {
	m := new(ProjectCloseMsg)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *netemClient) ProjectSave(ctx context.Context, in *ProjectRequest, opts ...grpc.CallOption) (Netem_ProjectSaveClient, error) {
	stream, err := c.cc.NewStream(ctx, &Netem_ServiceDesc.Streams[2], Netem_ProjectSave_FullMethodName, opts...)
	if err != nil {
		return nil, err
	}
	x := &netemProjectSaveClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Netem_ProjectSaveClient interface {
	Recv() (*ProjectSaveMsg, error)
	grpc.ClientStream
}

type netemProjectSaveClient struct {
	grpc.ClientStream
}

func (x *netemProjectSaveClient) Recv() (*ProjectSaveMsg, error) {
	m := new(ProjectSaveMsg)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *netemClient) ProjectGetNodeConfigs(ctx context.Context, in *ProjectRequest, opts ...grpc.CallOption) (*FileResponse, error) {
	out := new(FileResponse)
	err := c.cc.Invoke(ctx, Netem_ProjectGetNodeConfigs_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *netemClient) ProjectGetStatus(ctx context.Context, in *ProjectRequest, opts ...grpc.CallOption) (*StatusResponse, error) {
	out := new(StatusResponse)
	err := c.cc.Invoke(ctx, Netem_ProjectGetStatus_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *netemClient) ReadNetworkFile(ctx context.Context, in *ProjectRequest, opts ...grpc.CallOption) (*FileResponse, error) {
	out := new(FileResponse)
	err := c.cc.Invoke(ctx, Netem_ReadNetworkFile_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *netemClient) WriteNetworkFile(ctx context.Context, in *WNetworkRequest, opts ...grpc.CallOption) (*AckResponse, error) {
	out := new(AckResponse)
	err := c.cc.Invoke(ctx, Netem_WriteNetworkFile_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *netemClient) TopologyCheck(ctx context.Context, in *ProjectRequest, opts ...grpc.CallOption) (*AckResponse, error) {
	out := new(AckResponse)
	err := c.cc.Invoke(ctx, Netem_TopologyCheck_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *netemClient) TopologyReload(ctx context.Context, in *ProjectRequest, opts ...grpc.CallOption) (Netem_TopologyReloadClient, error) {
	stream, err := c.cc.NewStream(ctx, &Netem_ServiceDesc.Streams[3], Netem_TopologyReload_FullMethodName, opts...)
	if err != nil {
		return nil, err
	}
	x := &netemTopologyReloadClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Netem_TopologyReloadClient interface {
	Recv() (*TopologyRunMsg, error)
	grpc.ClientStream
}

type netemTopologyReloadClient struct {
	grpc.ClientStream
}

func (x *netemTopologyReloadClient) Recv() (*TopologyRunMsg, error) {
	m := new(TopologyRunMsg)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *netemClient) TopologyRun(ctx context.Context, in *ProjectRequest, opts ...grpc.CallOption) (Netem_TopologyRunClient, error) {
	stream, err := c.cc.NewStream(ctx, &Netem_ServiceDesc.Streams[4], Netem_TopologyRun_FullMethodName, opts...)
	if err != nil {
		return nil, err
	}
	x := &netemTopologyRunClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Netem_TopologyRunClient interface {
	Recv() (*TopologyRunMsg, error)
	grpc.ClientStream
}

type netemTopologyRunClient struct {
	grpc.ClientStream
}

func (x *netemTopologyRunClient) Recv() (*TopologyRunMsg, error) {
	m := new(TopologyRunMsg)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *netemClient) TopologyStartAll(ctx context.Context, in *ProjectRequest, opts ...grpc.CallOption) (*AckResponse, error) {
	out := new(AckResponse)
	err := c.cc.Invoke(ctx, Netem_TopologyStartAll_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *netemClient) TopologyStopAll(ctx context.Context, in *ProjectRequest, opts ...grpc.CallOption) (*AckResponse, error) {
	out := new(AckResponse)
	err := c.cc.Invoke(ctx, Netem_TopologyStopAll_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *netemClient) NodeReadConfigFiles(ctx context.Context, in *NodeRequest, opts ...grpc.CallOption) (*ConfigFilesResponse, error) {
	out := new(ConfigFilesResponse)
	err := c.cc.Invoke(ctx, Netem_NodeReadConfigFiles_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *netemClient) NodeCanRunConsole(ctx context.Context, in *NodeRequest, opts ...grpc.CallOption) (*AckResponse, error) {
	out := new(AckResponse)
	err := c.cc.Invoke(ctx, Netem_NodeCanRunConsole_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *netemClient) NodeConsole(ctx context.Context, opts ...grpc.CallOption) (Netem_NodeConsoleClient, error) {
	stream, err := c.cc.NewStream(ctx, &Netem_ServiceDesc.Streams[5], Netem_NodeConsole_FullMethodName, opts...)
	if err != nil {
		return nil, err
	}
	x := &netemNodeConsoleClient{stream}
	return x, nil
}

type Netem_NodeConsoleClient interface {
	Send(*ConsoleCltMsg) error
	Recv() (*ConsoleSrvMsg, error)
	grpc.ClientStream
}

type netemNodeConsoleClient struct {
	grpc.ClientStream
}

func (x *netemNodeConsoleClient) Send(m *ConsoleCltMsg) error {
	return x.ClientStream.SendMsg(m)
}

func (x *netemNodeConsoleClient) Recv() (*ConsoleSrvMsg, error) {
	m := new(ConsoleSrvMsg)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *netemClient) NodeStart(ctx context.Context, in *NodeRequest, opts ...grpc.CallOption) (*AckResponse, error) {
	out := new(AckResponse)
	err := c.cc.Invoke(ctx, Netem_NodeStart_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *netemClient) NodeStop(ctx context.Context, in *NodeRequest, opts ...grpc.CallOption) (*AckResponse, error) {
	out := new(AckResponse)
	err := c.cc.Invoke(ctx, Netem_NodeStop_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *netemClient) NodeRestart(ctx context.Context, in *NodeRequest, opts ...grpc.CallOption) (*AckResponse, error) {
	out := new(AckResponse)
	err := c.cc.Invoke(ctx, Netem_NodeRestart_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *netemClient) NodeSetIfState(ctx context.Context, in *NodeIfStateRequest, opts ...grpc.CallOption) (*AckResponse, error) {
	out := new(AckResponse)
	err := c.cc.Invoke(ctx, Netem_NodeSetIfState_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *netemClient) NodeCapture(ctx context.Context, in *NodeInterfaceRequest, opts ...grpc.CallOption) (Netem_NodeCaptureClient, error) {
	stream, err := c.cc.NewStream(ctx, &Netem_ServiceDesc.Streams[6], Netem_NodeCapture_FullMethodName, opts...)
	if err != nil {
		return nil, err
	}
	x := &netemNodeCaptureClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Netem_NodeCaptureClient interface {
	Recv() (*CaptureSrvMsg, error)
	grpc.ClientStream
}

type netemNodeCaptureClient struct {
	grpc.ClientStream
}

func (x *netemNodeCaptureClient) Recv() (*CaptureSrvMsg, error) {
	m := new(CaptureSrvMsg)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *netemClient) NodeCopyFrom(ctx context.Context, in *CopyMsg, opts ...grpc.CallOption) (Netem_NodeCopyFromClient, error) {
	stream, err := c.cc.NewStream(ctx, &Netem_ServiceDesc.Streams[7], Netem_NodeCopyFrom_FullMethodName, opts...)
	if err != nil {
		return nil, err
	}
	x := &netemNodeCopyFromClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Netem_NodeCopyFromClient interface {
	Recv() (*CopyMsg, error)
	grpc.ClientStream
}

type netemNodeCopyFromClient struct {
	grpc.ClientStream
}

func (x *netemNodeCopyFromClient) Recv() (*CopyMsg, error) {
	m := new(CopyMsg)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *netemClient) NodeCopyTo(ctx context.Context, opts ...grpc.CallOption) (Netem_NodeCopyToClient, error) {
	stream, err := c.cc.NewStream(ctx, &Netem_ServiceDesc.Streams[8], Netem_NodeCopyTo_FullMethodName, opts...)
	if err != nil {
		return nil, err
	}
	x := &netemNodeCopyToClient{stream}
	return x, nil
}

type Netem_NodeCopyToClient interface {
	Send(*CopyMsg) error
	CloseAndRecv() (*AckResponse, error)
	grpc.ClientStream
}

type netemNodeCopyToClient struct {
	grpc.ClientStream
}

func (x *netemNodeCopyToClient) Send(m *CopyMsg) error {
	return x.ClientStream.SendMsg(m)
}

func (x *netemNodeCopyToClient) CloseAndRecv() (*AckResponse, error) {
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	m := new(AckResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *netemClient) LinkUpdate(ctx context.Context, in *LinkRequest, opts ...grpc.CallOption) (*AckResponse, error) {
	out := new(AckResponse)
	err := c.cc.Invoke(ctx, Netem_LinkUpdate_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// NetemServer is the server API for Netem service.
// All implementations must embed UnimplementedNetemServer
// for forward compatibility
type NetemServer interface {
	// Server actions
	ServerGetVersion(context.Context, *emptypb.Empty) (*VersionResponse, error)
	ServerPullImages(*emptypb.Empty, Netem_ServerPullImagesServer) error
	ServerCleanContainers(context.Context, *emptypb.Empty) (*AckResponse, error)
	// Project actions
	ProjectGetMany(context.Context, *emptypb.Empty) (*PrjListResponse, error)
	ProjectOpen(context.Context, *OpenRequest) (*PrjOpenResponse, error)
	ProjectClose(*ProjectRequest, Netem_ProjectCloseServer) error
	ProjectSave(*ProjectRequest, Netem_ProjectSaveServer) error
	ProjectGetNodeConfigs(context.Context, *ProjectRequest) (*FileResponse, error)
	ProjectGetStatus(context.Context, *ProjectRequest) (*StatusResponse, error)
	// Read/Write network topology
	ReadNetworkFile(context.Context, *ProjectRequest) (*FileResponse, error)
	WriteNetworkFile(context.Context, *WNetworkRequest) (*AckResponse, error)
	// topology actions
	TopologyCheck(context.Context, *ProjectRequest) (*AckResponse, error)
	TopologyReload(*ProjectRequest, Netem_TopologyReloadServer) error
	TopologyRun(*ProjectRequest, Netem_TopologyRunServer) error
	TopologyStartAll(context.Context, *ProjectRequest) (*AckResponse, error)
	TopologyStopAll(context.Context, *ProjectRequest) (*AckResponse, error)
	// Node actions
	NodeReadConfigFiles(context.Context, *NodeRequest) (*ConfigFilesResponse, error)
	NodeCanRunConsole(context.Context, *NodeRequest) (*AckResponse, error)
	NodeConsole(Netem_NodeConsoleServer) error
	NodeStart(context.Context, *NodeRequest) (*AckResponse, error)
	NodeStop(context.Context, *NodeRequest) (*AckResponse, error)
	NodeRestart(context.Context, *NodeRequest) (*AckResponse, error)
	NodeSetIfState(context.Context, *NodeIfStateRequest) (*AckResponse, error)
	NodeCapture(*NodeInterfaceRequest, Netem_NodeCaptureServer) error
	NodeCopyFrom(*CopyMsg, Netem_NodeCopyFromServer) error
	NodeCopyTo(Netem_NodeCopyToServer) error
	// Link actions
	LinkUpdate(context.Context, *LinkRequest) (*AckResponse, error)
	mustEmbedUnimplementedNetemServer()
}

// UnimplementedNetemServer must be embedded to have forward compatible implementations.
type UnimplementedNetemServer struct {
}

func (UnimplementedNetemServer) ServerGetVersion(context.Context, *emptypb.Empty) (*VersionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ServerGetVersion not implemented")
}
func (UnimplementedNetemServer) ServerPullImages(*emptypb.Empty, Netem_ServerPullImagesServer) error {
	return status.Errorf(codes.Unimplemented, "method ServerPullImages not implemented")
}
func (UnimplementedNetemServer) ServerCleanContainers(context.Context, *emptypb.Empty) (*AckResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ServerCleanContainers not implemented")
}
func (UnimplementedNetemServer) ProjectGetMany(context.Context, *emptypb.Empty) (*PrjListResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ProjectGetMany not implemented")
}
func (UnimplementedNetemServer) ProjectOpen(context.Context, *OpenRequest) (*PrjOpenResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ProjectOpen not implemented")
}
func (UnimplementedNetemServer) ProjectClose(*ProjectRequest, Netem_ProjectCloseServer) error {
	return status.Errorf(codes.Unimplemented, "method ProjectClose not implemented")
}
func (UnimplementedNetemServer) ProjectSave(*ProjectRequest, Netem_ProjectSaveServer) error {
	return status.Errorf(codes.Unimplemented, "method ProjectSave not implemented")
}
func (UnimplementedNetemServer) ProjectGetNodeConfigs(context.Context, *ProjectRequest) (*FileResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ProjectGetNodeConfigs not implemented")
}
func (UnimplementedNetemServer) ProjectGetStatus(context.Context, *ProjectRequest) (*StatusResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ProjectGetStatus not implemented")
}
func (UnimplementedNetemServer) ReadNetworkFile(context.Context, *ProjectRequest) (*FileResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ReadNetworkFile not implemented")
}
func (UnimplementedNetemServer) WriteNetworkFile(context.Context, *WNetworkRequest) (*AckResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method WriteNetworkFile not implemented")
}
func (UnimplementedNetemServer) TopologyCheck(context.Context, *ProjectRequest) (*AckResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TopologyCheck not implemented")
}
func (UnimplementedNetemServer) TopologyReload(*ProjectRequest, Netem_TopologyReloadServer) error {
	return status.Errorf(codes.Unimplemented, "method TopologyReload not implemented")
}
func (UnimplementedNetemServer) TopologyRun(*ProjectRequest, Netem_TopologyRunServer) error {
	return status.Errorf(codes.Unimplemented, "method TopologyRun not implemented")
}
func (UnimplementedNetemServer) TopologyStartAll(context.Context, *ProjectRequest) (*AckResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TopologyStartAll not implemented")
}
func (UnimplementedNetemServer) TopologyStopAll(context.Context, *ProjectRequest) (*AckResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TopologyStopAll not implemented")
}
func (UnimplementedNetemServer) NodeReadConfigFiles(context.Context, *NodeRequest) (*ConfigFilesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method NodeReadConfigFiles not implemented")
}
func (UnimplementedNetemServer) NodeCanRunConsole(context.Context, *NodeRequest) (*AckResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method NodeCanRunConsole not implemented")
}
func (UnimplementedNetemServer) NodeConsole(Netem_NodeConsoleServer) error {
	return status.Errorf(codes.Unimplemented, "method NodeConsole not implemented")
}
func (UnimplementedNetemServer) NodeStart(context.Context, *NodeRequest) (*AckResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method NodeStart not implemented")
}
func (UnimplementedNetemServer) NodeStop(context.Context, *NodeRequest) (*AckResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method NodeStop not implemented")
}
func (UnimplementedNetemServer) NodeRestart(context.Context, *NodeRequest) (*AckResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method NodeRestart not implemented")
}
func (UnimplementedNetemServer) NodeSetIfState(context.Context, *NodeIfStateRequest) (*AckResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method NodeSetIfState not implemented")
}
func (UnimplementedNetemServer) NodeCapture(*NodeInterfaceRequest, Netem_NodeCaptureServer) error {
	return status.Errorf(codes.Unimplemented, "method NodeCapture not implemented")
}
func (UnimplementedNetemServer) NodeCopyFrom(*CopyMsg, Netem_NodeCopyFromServer) error {
	return status.Errorf(codes.Unimplemented, "method NodeCopyFrom not implemented")
}
func (UnimplementedNetemServer) NodeCopyTo(Netem_NodeCopyToServer) error {
	return status.Errorf(codes.Unimplemented, "method NodeCopyTo not implemented")
}
func (UnimplementedNetemServer) LinkUpdate(context.Context, *LinkRequest) (*AckResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method LinkUpdate not implemented")
}
func (UnimplementedNetemServer) mustEmbedUnimplementedNetemServer() {}

// UnsafeNetemServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to NetemServer will
// result in compilation errors.
type UnsafeNetemServer interface {
	mustEmbedUnimplementedNetemServer()
}

func RegisterNetemServer(s grpc.ServiceRegistrar, srv NetemServer) {
	s.RegisterService(&Netem_ServiceDesc, srv)
}

func _Netem_ServerGetVersion_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NetemServer).ServerGetVersion(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Netem_ServerGetVersion_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NetemServer).ServerGetVersion(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Netem_ServerPullImages_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(emptypb.Empty)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(NetemServer).ServerPullImages(m, &netemServerPullImagesServer{stream})
}

type Netem_ServerPullImagesServer interface {
	Send(*PullSrvMsg) error
	grpc.ServerStream
}

type netemServerPullImagesServer struct {
	grpc.ServerStream
}

func (x *netemServerPullImagesServer) Send(m *PullSrvMsg) error {
	return x.ServerStream.SendMsg(m)
}

func _Netem_ServerCleanContainers_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NetemServer).ServerCleanContainers(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Netem_ServerCleanContainers_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NetemServer).ServerCleanContainers(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Netem_ProjectGetMany_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NetemServer).ProjectGetMany(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Netem_ProjectGetMany_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NetemServer).ProjectGetMany(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Netem_ProjectOpen_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(OpenRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NetemServer).ProjectOpen(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Netem_ProjectOpen_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NetemServer).ProjectOpen(ctx, req.(*OpenRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Netem_ProjectClose_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(ProjectRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(NetemServer).ProjectClose(m, &netemProjectCloseServer{stream})
}

type Netem_ProjectCloseServer interface {
	Send(*ProjectCloseMsg) error
	grpc.ServerStream
}

type netemProjectCloseServer struct {
	grpc.ServerStream
}

func (x *netemProjectCloseServer) Send(m *ProjectCloseMsg) error {
	return x.ServerStream.SendMsg(m)
}

func _Netem_ProjectSave_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(ProjectRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(NetemServer).ProjectSave(m, &netemProjectSaveServer{stream})
}

type Netem_ProjectSaveServer interface {
	Send(*ProjectSaveMsg) error
	grpc.ServerStream
}

type netemProjectSaveServer struct {
	grpc.ServerStream
}

func (x *netemProjectSaveServer) Send(m *ProjectSaveMsg) error {
	return x.ServerStream.SendMsg(m)
}

func _Netem_ProjectGetNodeConfigs_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ProjectRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NetemServer).ProjectGetNodeConfigs(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Netem_ProjectGetNodeConfigs_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NetemServer).ProjectGetNodeConfigs(ctx, req.(*ProjectRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Netem_ProjectGetStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ProjectRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NetemServer).ProjectGetStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Netem_ProjectGetStatus_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NetemServer).ProjectGetStatus(ctx, req.(*ProjectRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Netem_ReadNetworkFile_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ProjectRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NetemServer).ReadNetworkFile(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Netem_ReadNetworkFile_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NetemServer).ReadNetworkFile(ctx, req.(*ProjectRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Netem_WriteNetworkFile_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(WNetworkRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NetemServer).WriteNetworkFile(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Netem_WriteNetworkFile_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NetemServer).WriteNetworkFile(ctx, req.(*WNetworkRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Netem_TopologyCheck_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ProjectRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NetemServer).TopologyCheck(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Netem_TopologyCheck_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NetemServer).TopologyCheck(ctx, req.(*ProjectRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Netem_TopologyReload_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(ProjectRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(NetemServer).TopologyReload(m, &netemTopologyReloadServer{stream})
}

type Netem_TopologyReloadServer interface {
	Send(*TopologyRunMsg) error
	grpc.ServerStream
}

type netemTopologyReloadServer struct {
	grpc.ServerStream
}

func (x *netemTopologyReloadServer) Send(m *TopologyRunMsg) error {
	return x.ServerStream.SendMsg(m)
}

func _Netem_TopologyRun_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(ProjectRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(NetemServer).TopologyRun(m, &netemTopologyRunServer{stream})
}

type Netem_TopologyRunServer interface {
	Send(*TopologyRunMsg) error
	grpc.ServerStream
}

type netemTopologyRunServer struct {
	grpc.ServerStream
}

func (x *netemTopologyRunServer) Send(m *TopologyRunMsg) error {
	return x.ServerStream.SendMsg(m)
}

func _Netem_TopologyStartAll_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ProjectRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NetemServer).TopologyStartAll(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Netem_TopologyStartAll_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NetemServer).TopologyStartAll(ctx, req.(*ProjectRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Netem_TopologyStopAll_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ProjectRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NetemServer).TopologyStopAll(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Netem_TopologyStopAll_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NetemServer).TopologyStopAll(ctx, req.(*ProjectRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Netem_NodeReadConfigFiles_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NodeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NetemServer).NodeReadConfigFiles(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Netem_NodeReadConfigFiles_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NetemServer).NodeReadConfigFiles(ctx, req.(*NodeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Netem_NodeCanRunConsole_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NodeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NetemServer).NodeCanRunConsole(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Netem_NodeCanRunConsole_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NetemServer).NodeCanRunConsole(ctx, req.(*NodeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Netem_NodeConsole_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(NetemServer).NodeConsole(&netemNodeConsoleServer{stream})
}

type Netem_NodeConsoleServer interface {
	Send(*ConsoleSrvMsg) error
	Recv() (*ConsoleCltMsg, error)
	grpc.ServerStream
}

type netemNodeConsoleServer struct {
	grpc.ServerStream
}

func (x *netemNodeConsoleServer) Send(m *ConsoleSrvMsg) error {
	return x.ServerStream.SendMsg(m)
}

func (x *netemNodeConsoleServer) Recv() (*ConsoleCltMsg, error) {
	m := new(ConsoleCltMsg)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _Netem_NodeStart_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NodeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NetemServer).NodeStart(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Netem_NodeStart_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NetemServer).NodeStart(ctx, req.(*NodeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Netem_NodeStop_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NodeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NetemServer).NodeStop(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Netem_NodeStop_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NetemServer).NodeStop(ctx, req.(*NodeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Netem_NodeRestart_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NodeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NetemServer).NodeRestart(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Netem_NodeRestart_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NetemServer).NodeRestart(ctx, req.(*NodeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Netem_NodeSetIfState_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NodeIfStateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NetemServer).NodeSetIfState(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Netem_NodeSetIfState_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NetemServer).NodeSetIfState(ctx, req.(*NodeIfStateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Netem_NodeCapture_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(NodeInterfaceRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(NetemServer).NodeCapture(m, &netemNodeCaptureServer{stream})
}

type Netem_NodeCaptureServer interface {
	Send(*CaptureSrvMsg) error
	grpc.ServerStream
}

type netemNodeCaptureServer struct {
	grpc.ServerStream
}

func (x *netemNodeCaptureServer) Send(m *CaptureSrvMsg) error {
	return x.ServerStream.SendMsg(m)
}

func _Netem_NodeCopyFrom_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(CopyMsg)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(NetemServer).NodeCopyFrom(m, &netemNodeCopyFromServer{stream})
}

type Netem_NodeCopyFromServer interface {
	Send(*CopyMsg) error
	grpc.ServerStream
}

type netemNodeCopyFromServer struct {
	grpc.ServerStream
}

func (x *netemNodeCopyFromServer) Send(m *CopyMsg) error {
	return x.ServerStream.SendMsg(m)
}

func _Netem_NodeCopyTo_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(NetemServer).NodeCopyTo(&netemNodeCopyToServer{stream})
}

type Netem_NodeCopyToServer interface {
	SendAndClose(*AckResponse) error
	Recv() (*CopyMsg, error)
	grpc.ServerStream
}

type netemNodeCopyToServer struct {
	grpc.ServerStream
}

func (x *netemNodeCopyToServer) SendAndClose(m *AckResponse) error {
	return x.ServerStream.SendMsg(m)
}

func (x *netemNodeCopyToServer) Recv() (*CopyMsg, error) {
	m := new(CopyMsg)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _Netem_LinkUpdate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LinkRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NetemServer).LinkUpdate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Netem_LinkUpdate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NetemServer).LinkUpdate(ctx, req.(*LinkRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// Netem_ServiceDesc is the grpc.ServiceDesc for Netem service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Netem_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "netem.Netem",
	HandlerType: (*NetemServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ServerGetVersion",
			Handler:    _Netem_ServerGetVersion_Handler,
		},
		{
			MethodName: "ServerCleanContainers",
			Handler:    _Netem_ServerCleanContainers_Handler,
		},
		{
			MethodName: "ProjectGetMany",
			Handler:    _Netem_ProjectGetMany_Handler,
		},
		{
			MethodName: "ProjectOpen",
			Handler:    _Netem_ProjectOpen_Handler,
		},
		{
			MethodName: "ProjectGetNodeConfigs",
			Handler:    _Netem_ProjectGetNodeConfigs_Handler,
		},
		{
			MethodName: "ProjectGetStatus",
			Handler:    _Netem_ProjectGetStatus_Handler,
		},
		{
			MethodName: "ReadNetworkFile",
			Handler:    _Netem_ReadNetworkFile_Handler,
		},
		{
			MethodName: "WriteNetworkFile",
			Handler:    _Netem_WriteNetworkFile_Handler,
		},
		{
			MethodName: "TopologyCheck",
			Handler:    _Netem_TopologyCheck_Handler,
		},
		{
			MethodName: "TopologyStartAll",
			Handler:    _Netem_TopologyStartAll_Handler,
		},
		{
			MethodName: "TopologyStopAll",
			Handler:    _Netem_TopologyStopAll_Handler,
		},
		{
			MethodName: "NodeReadConfigFiles",
			Handler:    _Netem_NodeReadConfigFiles_Handler,
		},
		{
			MethodName: "NodeCanRunConsole",
			Handler:    _Netem_NodeCanRunConsole_Handler,
		},
		{
			MethodName: "NodeStart",
			Handler:    _Netem_NodeStart_Handler,
		},
		{
			MethodName: "NodeStop",
			Handler:    _Netem_NodeStop_Handler,
		},
		{
			MethodName: "NodeRestart",
			Handler:    _Netem_NodeRestart_Handler,
		},
		{
			MethodName: "NodeSetIfState",
			Handler:    _Netem_NodeSetIfState_Handler,
		},
		{
			MethodName: "LinkUpdate",
			Handler:    _Netem_LinkUpdate_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "ServerPullImages",
			Handler:       _Netem_ServerPullImages_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "ProjectClose",
			Handler:       _Netem_ProjectClose_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "ProjectSave",
			Handler:       _Netem_ProjectSave_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "TopologyReload",
			Handler:       _Netem_TopologyReload_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "TopologyRun",
			Handler:       _Netem_TopologyRun_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "NodeConsole",
			Handler:       _Netem_NodeConsole_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
		{
			StreamName:    "NodeCapture",
			Handler:       _Netem_NodeCapture_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "NodeCopyFrom",
			Handler:       _Netem_NodeCopyFrom_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "NodeCopyTo",
			Handler:       _Netem_NodeCopyTo_Handler,
			ClientStreams: true,
		},
	},
	Metadata: "internal/proto/netem.proto",
}

// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.3.0
// - protoc             v4.25.3
// source: internal/proto/netem.proto

package proto

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	emptypb "google.golang.org/protobuf/types/known/emptypb"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

const (
	Netem_ServerGetVersion_FullMethodName      = "/netem.Netem/ServerGetVersion"
	Netem_ServerPullImages_FullMethodName      = "/netem.Netem/ServerPullImages"
	Netem_ServerCleanContainers_FullMethodName = "/netem.Netem/ServerCleanContainers"
	Netem_ProjectGetMany_FullMethodName        = "/netem.Netem/ProjectGetMany"
	Netem_ProjectOpen_FullMethodName           = "/netem.Netem/ProjectOpen"
	Netem_ProjectClose_FullMethodName          = "/netem.Netem/ProjectClose"
	Netem_ProjectSave_FullMethodName           = "/netem.Netem/ProjectSave"
	Netem_ProjectGetNodeConfigs_FullMethodName = "/netem.Netem/ProjectGetNodeConfigs"
	Netem_ProjectGetStatus_FullMethodName      = "/netem.Netem/ProjectGetStatus"
	Netem_ReadNetworkFile_FullMethodName       = "/netem.Netem/ReadNetworkFile"
	Netem_WriteNetworkFile_FullMethodName      = "/netem.Netem/WriteNetworkFile"
	Netem_Check_FullMethodName                 = "/netem.Netem/Check"
	Netem_TopologyReload_FullMethodName        = "/netem.Netem/TopologyReload"
	Netem_TopologyRun_FullMethodName           = "/netem.Netem/TopologyRun"
	Netem_TopologyStartAll_FullMethodName      = "/netem.Netem/TopologyStartAll"
	Netem_TopologyStopAll_FullMethodName       = "/netem.Netem/TopologyStopAll"
	Netem_ReadConfigFiles_FullMethodName       = "/netem.Netem/ReadConfigFiles"
	Netem_CanRunConsole_FullMethodName         = "/netem.Netem/CanRunConsole"
	Netem_Console_FullMethodName               = "/netem.Netem/Console"
	Netem_Start_FullMethodName                 = "/netem.Netem/Start"
	Netem_Stop_FullMethodName                  = "/netem.Netem/Stop"
	Netem_Restart_FullMethodName               = "/netem.Netem/Restart"
	Netem_SetIfState_FullMethodName            = "/netem.Netem/SetIfState"
	Netem_Capture_FullMethodName               = "/netem.Netem/Capture"
	Netem_CopyFrom_FullMethodName              = "/netem.Netem/CopyFrom"
	Netem_CopyTo_FullMethodName                = "/netem.Netem/CopyTo"
	Netem_LinkUpdate_FullMethodName            = "/netem.Netem/LinkUpdate"
)

// NetemClient is the client API for Netem service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type NetemClient interface {
	// general action
	ServerGetVersion(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*VersionResponse, error)
	ServerPullImages(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (Netem_ServerPullImagesClient, error)
	ServerCleanContainers(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*AckResponse, error)
	// Project actions
	ProjectGetMany(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*PrjListResponse, error)
	ProjectOpen(ctx context.Context, in *OpenRequest, opts ...grpc.CallOption) (*PrjOpenResponse, error)
	ProjectClose(ctx context.Context, in *ProjectRequest, opts ...grpc.CallOption) (Netem_ProjectCloseClient, error)
	ProjectSave(ctx context.Context, in *ProjectRequest, opts ...grpc.CallOption) (Netem_ProjectSaveClient, error)
	ProjectGetNodeConfigs(ctx context.Context, in *ProjectRequest, opts ...grpc.CallOption) (*FileResponse, error)
	ProjectGetStatus(ctx context.Context, in *ProjectRequest, opts ...grpc.CallOption) (*StatusResponse, error)
	// Read/Write network topology
	ReadNetworkFile(ctx context.Context, in *ProjectRequest, opts ...grpc.CallOption) (*FileResponse, error)
	WriteNetworkFile(ctx context.Context, in *WNetworkRequest, opts ...grpc.CallOption) (*AckResponse, error)
	// topology actions
	Check(ctx context.Context, in *ProjectRequest, opts ...grpc.CallOption) (*AckResponse, error)
	TopologyReload(ctx context.Context, in *ProjectRequest, opts ...grpc.CallOption) (Netem_TopologyReloadClient, error)
	TopologyRun(ctx context.Context, in *ProjectRequest, opts ...grpc.CallOption) (Netem_TopologyRunClient, error)
	TopologyStartAll(ctx context.Context, in *ProjectRequest, opts ...grpc.CallOption) (*AckResponse, error)
	TopologyStopAll(ctx context.Context, in *ProjectRequest, opts ...grpc.CallOption) (*AckResponse, error)
	// Node actions
	ReadConfigFiles(ctx context.Context, in *NodeRequest, opts ...grpc.CallOption) (*ConfigFilesResponse, error)
	CanRunConsole(ctx context.Context, in *NodeRequest, opts ...grpc.CallOption) (*AckResponse, error)
	Console(ctx context.Context, opts ...grpc.CallOption) (Netem_ConsoleClient, error)
	Start(ctx context.Context, in *NodeRequest, opts ...grpc.CallOption) (*AckResponse, error)
	Stop(ctx context.Context, in *NodeRequest, opts ...grpc.CallOption) (*AckResponse, error)
	Restart(ctx context.Context, in *NodeRequest, opts ...grpc.CallOption) (*AckResponse, error)
	SetIfState(ctx context.Context, in *NodeIfStateRequest, opts ...grpc.CallOption) (*AckResponse, error)
	Capture(ctx context.Context, in *NodeInterfaceRequest, opts ...grpc.CallOption) (Netem_CaptureClient, error)
	CopyFrom(ctx context.Context, in *CopyMsg, opts ...grpc.CallOption) (Netem_CopyFromClient, error)
	CopyTo(ctx context.Context, opts ...grpc.CallOption) (Netem_CopyToClient, error)
	// Link actions
	LinkUpdate(ctx context.Context, in *LinkRequest, opts ...grpc.CallOption) (*AckResponse, error)
}

type netemClient struct {
	cc grpc.ClientConnInterface
}

func NewNetemClient(cc grpc.ClientConnInterface) NetemClient {
	return &netemClient{cc}
}

func (c *netemClient) ServerGetVersion(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*VersionResponse, error) {
	out := new(VersionResponse)
	err := c.cc.Invoke(ctx, Netem_ServerGetVersion_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *netemClient) ServerPullImages(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (Netem_ServerPullImagesClient, error) {
	stream, err := c.cc.NewStream(ctx, &Netem_ServiceDesc.Streams[0], Netem_ServerPullImages_FullMethodName, opts...)
	if err != nil {
		return nil, err
	}
	x := &netemServerPullImagesClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Netem_ServerPullImagesClient interface {
	Recv() (*PullSrvMsg, error)
	grpc.ClientStream
}

type netemServerPullImagesClient struct {
	grpc.ClientStream
}

func (x *netemServerPullImagesClient) Recv() (*PullSrvMsg, error) {
	m := new(PullSrvMsg)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *netemClient) ServerCleanContainers(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*AckResponse, error) {
	out := new(AckResponse)
	err := c.cc.Invoke(ctx, Netem_ServerCleanContainers_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *netemClient) ProjectGetMany(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*PrjListResponse, error) {
	out := new(PrjListResponse)
	err := c.cc.Invoke(ctx, Netem_ProjectGetMany_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *netemClient) ProjectOpen(ctx context.Context, in *OpenRequest, opts ...grpc.CallOption) (*PrjOpenResponse, error) {
	out := new(PrjOpenResponse)
	err := c.cc.Invoke(ctx, Netem_ProjectOpen_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *netemClient) ProjectClose(ctx context.Context, in *ProjectRequest, opts ...grpc.CallOption) (Netem_ProjectCloseClient, error) {
	stream, err := c.cc.NewStream(ctx, &Netem_ServiceDesc.Streams[1], Netem_ProjectClose_FullMethodName, opts...)
	if err != nil {
		return nil, err
	}
	x := &netemProjectCloseClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Netem_ProjectCloseClient interface {
	Recv() (*ProjectCloseMsg, error)
	grpc.ClientStream
}

type netemProjectCloseClient struct {
	grpc.ClientStream
}

func (x *netemProjectCloseClient) Recv() (*ProjectCloseMsg, error) {
	m := new(ProjectCloseMsg)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *netemClient) ProjectSave(ctx context.Context, in *ProjectRequest, opts ...grpc.CallOption) (Netem_ProjectSaveClient, error) {
	stream, err := c.cc.NewStream(ctx, &Netem_ServiceDesc.Streams[2], Netem_ProjectSave_FullMethodName, opts...)
	if err != nil {
		return nil, err
	}
	x := &netemProjectSaveClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Netem_ProjectSaveClient interface {
	Recv() (*ProjectSaveMsg, error)
	grpc.ClientStream
}

type netemProjectSaveClient struct {
	grpc.ClientStream
}

func (x *netemProjectSaveClient) Recv() (*ProjectSaveMsg, error) {
	m := new(ProjectSaveMsg)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *netemClient) ProjectGetNodeConfigs(ctx context.Context, in *ProjectRequest, opts ...grpc.CallOption) (*FileResponse, error) {
	out := new(FileResponse)
	err := c.cc.Invoke(ctx, Netem_ProjectGetNodeConfigs_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *netemClient) ProjectGetStatus(ctx context.Context, in *ProjectRequest, opts ...grpc.CallOption) (*StatusResponse, error) {
	out := new(StatusResponse)
	err := c.cc.Invoke(ctx, Netem_ProjectGetStatus_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *netemClient) ReadNetworkFile(ctx context.Context, in *ProjectRequest, opts ...grpc.CallOption) (*FileResponse, error) {
	out := new(FileResponse)
	err := c.cc.Invoke(ctx, Netem_ReadNetworkFile_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *netemClient) WriteNetworkFile(ctx context.Context, in *WNetworkRequest, opts ...grpc.CallOption) (*AckResponse, error) {
	out := new(AckResponse)
	err := c.cc.Invoke(ctx, Netem_WriteNetworkFile_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *netemClient) Check(ctx context.Context, in *ProjectRequest, opts ...grpc.CallOption) (*AckResponse, error) {
	out := new(AckResponse)
	err := c.cc.Invoke(ctx, Netem_Check_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *netemClient) TopologyReload(ctx context.Context, in *ProjectRequest, opts ...grpc.CallOption) (Netem_TopologyReloadClient, error) {
	stream, err := c.cc.NewStream(ctx, &Netem_ServiceDesc.Streams[3], Netem_TopologyReload_FullMethodName, opts...)
	if err != nil {
		return nil, err
	}
	x := &netemTopologyReloadClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Netem_TopologyReloadClient interface {
	Recv() (*TopologyRunMsg, error)
	grpc.ClientStream
}

type netemTopologyReloadClient struct {
	grpc.ClientStream
}

func (x *netemTopologyReloadClient) Recv() (*TopologyRunMsg, error) {
	m := new(TopologyRunMsg)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *netemClient) TopologyRun(ctx context.Context, in *ProjectRequest, opts ...grpc.CallOption) (Netem_TopologyRunClient, error) {
	stream, err := c.cc.NewStream(ctx, &Netem_ServiceDesc.Streams[4], Netem_TopologyRun_FullMethodName, opts...)
	if err != nil {
		return nil, err
	}
	x := &netemTopologyRunClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Netem_TopologyRunClient interface {
	Recv() (*TopologyRunMsg, error)
	grpc.ClientStream
}

type netemTopologyRunClient struct {
	grpc.ClientStream
}

func (x *netemTopologyRunClient) Recv() (*TopologyRunMsg, error) {
	m := new(TopologyRunMsg)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *netemClient) TopologyStartAll(ctx context.Context, in *ProjectRequest, opts ...grpc.CallOption) (*AckResponse, error) {
	out := new(AckResponse)
	err := c.cc.Invoke(ctx, Netem_TopologyStartAll_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *netemClient) TopologyStopAll(ctx context.Context, in *ProjectRequest, opts ...grpc.CallOption) (*AckResponse, error) {
	out := new(AckResponse)
	err := c.cc.Invoke(ctx, Netem_TopologyStopAll_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *netemClient) ReadConfigFiles(ctx context.Context, in *NodeRequest, opts ...grpc.CallOption) (*ConfigFilesResponse, error) {
	out := new(ConfigFilesResponse)
	err := c.cc.Invoke(ctx, Netem_ReadConfigFiles_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *netemClient) CanRunConsole(ctx context.Context, in *NodeRequest, opts ...grpc.CallOption) (*AckResponse, error) {
	out := new(AckResponse)
	err := c.cc.Invoke(ctx, Netem_CanRunConsole_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *netemClient) Console(ctx context.Context, opts ...grpc.CallOption) (Netem_ConsoleClient, error) {
	stream, err := c.cc.NewStream(ctx, &Netem_ServiceDesc.Streams[5], Netem_Console_FullMethodName, opts...)
	if err != nil {
		return nil, err
	}
	x := &netemConsoleClient{stream}
	return x, nil
}

type Netem_ConsoleClient interface {
	Send(*ConsoleCltMsg) error
	Recv() (*ConsoleSrvMsg, error)
	grpc.ClientStream
}

type netemConsoleClient struct {
	grpc.ClientStream
}

func (x *netemConsoleClient) Send(m *ConsoleCltMsg) error {
	return x.ClientStream.SendMsg(m)
}

func (x *netemConsoleClient) Recv() (*ConsoleSrvMsg, error) {
	m := new(ConsoleSrvMsg)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *netemClient) Start(ctx context.Context, in *NodeRequest, opts ...grpc.CallOption) (*AckResponse, error) {
	out := new(AckResponse)
	err := c.cc.Invoke(ctx, Netem_Start_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *netemClient) Stop(ctx context.Context, in *NodeRequest, opts ...grpc.CallOption) (*AckResponse, error) {
	out := new(AckResponse)
	err := c.cc.Invoke(ctx, Netem_Stop_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *netemClient) Restart(ctx context.Context, in *NodeRequest, opts ...grpc.CallOption) (*AckResponse, error) {
	out := new(AckResponse)
	err := c.cc.Invoke(ctx, Netem_Restart_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *netemClient) SetIfState(ctx context.Context, in *NodeIfStateRequest, opts ...grpc.CallOption) (*AckResponse, error) {
	out := new(AckResponse)
	err := c.cc.Invoke(ctx, Netem_SetIfState_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *netemClient) Capture(ctx context.Context, in *NodeInterfaceRequest, opts ...grpc.CallOption) (Netem_CaptureClient, error) {
	stream, err := c.cc.NewStream(ctx, &Netem_ServiceDesc.Streams[6], Netem_Capture_FullMethodName, opts...)
	if err != nil {
		return nil, err
	}
	x := &netemCaptureClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Netem_CaptureClient interface {
	Recv() (*CaptureSrvMsg, error)
	grpc.ClientStream
}

type netemCaptureClient struct {
	grpc.ClientStream
}

func (x *netemCaptureClient) Recv() (*CaptureSrvMsg, error) {
	m := new(CaptureSrvMsg)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *netemClient) CopyFrom(ctx context.Context, in *CopyMsg, opts ...grpc.CallOption) (Netem_CopyFromClient, error) {
	stream, err := c.cc.NewStream(ctx, &Netem_ServiceDesc.Streams[7], Netem_CopyFrom_FullMethodName, opts...)
	if err != nil {
		return nil, err
	}
	x := &netemCopyFromClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Netem_CopyFromClient interface {
	Recv() (*CopyMsg, error)
	grpc.ClientStream
}

type netemCopyFromClient struct {
	grpc.ClientStream
}

func (x *netemCopyFromClient) Recv() (*CopyMsg, error) {
	m := new(CopyMsg)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *netemClient) CopyTo(ctx context.Context, opts ...grpc.CallOption) (Netem_CopyToClient, error) {
	stream, err := c.cc.NewStream(ctx, &Netem_ServiceDesc.Streams[8], Netem_CopyTo_FullMethodName, opts...)
	if err != nil {
		return nil, err
	}
	x := &netemCopyToClient{stream}
	return x, nil
}

type Netem_CopyToClient interface {
	Send(*CopyMsg) error
	CloseAndRecv() (*AckResponse, error)
	grpc.ClientStream
}

type netemCopyToClient struct {
	grpc.ClientStream
}

func (x *netemCopyToClient) Send(m *CopyMsg) error {
	return x.ClientStream.SendMsg(m)
}

func (x *netemCopyToClient) CloseAndRecv() (*AckResponse, error) {
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	m := new(AckResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *netemClient) LinkUpdate(ctx context.Context, in *LinkRequest, opts ...grpc.CallOption) (*AckResponse, error) {
	out := new(AckResponse)
	err := c.cc.Invoke(ctx, Netem_LinkUpdate_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// NetemServer is the server API for Netem service.
// All implementations must embed UnimplementedNetemServer
// for forward compatibility
type NetemServer interface {
	// general action
	ServerGetVersion(context.Context, *emptypb.Empty) (*VersionResponse, error)
	ServerPullImages(*emptypb.Empty, Netem_ServerPullImagesServer) error
	ServerCleanContainers(context.Context, *emptypb.Empty) (*AckResponse, error)
	// Project actions
	ProjectGetMany(context.Context, *emptypb.Empty) (*PrjListResponse, error)
	ProjectOpen(context.Context, *OpenRequest) (*PrjOpenResponse, error)
	ProjectClose(*ProjectRequest, Netem_ProjectCloseServer) error
	ProjectSave(*ProjectRequest, Netem_ProjectSaveServer) error
	ProjectGetNodeConfigs(context.Context, *ProjectRequest) (*FileResponse, error)
	ProjectGetStatus(context.Context, *ProjectRequest) (*StatusResponse, error)
	// Read/Write network topology
	ReadNetworkFile(context.Context, *ProjectRequest) (*FileResponse, error)
	WriteNetworkFile(context.Context, *WNetworkRequest) (*AckResponse, error)
	// topology actions
	Check(context.Context, *ProjectRequest) (*AckResponse, error)
	TopologyReload(*ProjectRequest, Netem_TopologyReloadServer) error
	TopologyRun(*ProjectRequest, Netem_TopologyRunServer) error
	TopologyStartAll(context.Context, *ProjectRequest) (*AckResponse, error)
	TopologyStopAll(context.Context, *ProjectRequest) (*AckResponse, error)
	// Node actions
	ReadConfigFiles(context.Context, *NodeRequest) (*ConfigFilesResponse, error)
	CanRunConsole(context.Context, *NodeRequest) (*AckResponse, error)
	Console(Netem_ConsoleServer) error
	Start(context.Context, *NodeRequest) (*AckResponse, error)
	Stop(context.Context, *NodeRequest) (*AckResponse, error)
	Restart(context.Context, *NodeRequest) (*AckResponse, error)
	SetIfState(context.Context, *NodeIfStateRequest) (*AckResponse, error)
	Capture(*NodeInterfaceRequest, Netem_CaptureServer) error
	CopyFrom(*CopyMsg, Netem_CopyFromServer) error
	CopyTo(Netem_CopyToServer) error
	// Link actions
	LinkUpdate(context.Context, *LinkRequest) (*AckResponse, error)
	mustEmbedUnimplementedNetemServer()
}

// UnimplementedNetemServer must be embedded to have forward compatible implementations.
type UnimplementedNetemServer struct {
}

func (UnimplementedNetemServer) ServerGetVersion(context.Context, *emptypb.Empty) (*VersionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ServerGetVersion not implemented")
}
func (UnimplementedNetemServer) ServerPullImages(*emptypb.Empty, Netem_ServerPullImagesServer) error {
	return status.Errorf(codes.Unimplemented, "method ServerPullImages not implemented")
}
func (UnimplementedNetemServer) ServerCleanContainers(context.Context, *emptypb.Empty) (*AckResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ServerCleanContainers not implemented")
}
func (UnimplementedNetemServer) ProjectGetMany(context.Context, *emptypb.Empty) (*PrjListResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ProjectGetMany not implemented")
}
func (UnimplementedNetemServer) ProjectOpen(context.Context, *OpenRequest) (*PrjOpenResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ProjectOpen not implemented")
}
func (UnimplementedNetemServer) ProjectClose(*ProjectRequest, Netem_ProjectCloseServer) error {
	return status.Errorf(codes.Unimplemented, "method ProjectClose not implemented")
}
func (UnimplementedNetemServer) ProjectSave(*ProjectRequest, Netem_ProjectSaveServer) error {
	return status.Errorf(codes.Unimplemented, "method ProjectSave not implemented")
}
func (UnimplementedNetemServer) ProjectGetNodeConfigs(context.Context, *ProjectRequest) (*FileResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ProjectGetNodeConfigs not implemented")
}
func (UnimplementedNetemServer) ProjectGetStatus(context.Context, *ProjectRequest) (*StatusResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ProjectGetStatus not implemented")
}
func (UnimplementedNetemServer) ReadNetworkFile(context.Context, *ProjectRequest) (*FileResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ReadNetworkFile not implemented")
}
func (UnimplementedNetemServer) WriteNetworkFile(context.Context, *WNetworkRequest) (*AckResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method WriteNetworkFile not implemented")
}
func (UnimplementedNetemServer) Check(context.Context, *ProjectRequest) (*AckResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Check not implemented")
}
func (UnimplementedNetemServer) TopologyReload(*ProjectRequest, Netem_TopologyReloadServer) error {
	return status.Errorf(codes.Unimplemented, "method TopologyReload not implemented")
}
func (UnimplementedNetemServer) TopologyRun(*ProjectRequest, Netem_TopologyRunServer) error {
	return status.Errorf(codes.Unimplemented, "method TopologyRun not implemented")
}
func (UnimplementedNetemServer) TopologyStartAll(context.Context, *ProjectRequest) (*AckResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TopologyStartAll not implemented")
}
func (UnimplementedNetemServer) TopologyStopAll(context.Context, *ProjectRequest) (*AckResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TopologyStopAll not implemented")
}
func (UnimplementedNetemServer) ReadConfigFiles(context.Context, *NodeRequest) (*ConfigFilesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ReadConfigFiles not implemented")
}
func (UnimplementedNetemServer) CanRunConsole(context.Context, *NodeRequest) (*AckResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CanRunConsole not implemented")
}
func (UnimplementedNetemServer) Console(Netem_ConsoleServer) error {
	return status.Errorf(codes.Unimplemented, "method Console not implemented")
}
func (UnimplementedNetemServer) Start(context.Context, *NodeRequest) (*AckResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Start not implemented")
}
func (UnimplementedNetemServer) Stop(context.Context, *NodeRequest) (*AckResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Stop not implemented")
}
func (UnimplementedNetemServer) Restart(context.Context, *NodeRequest) (*AckResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Restart not implemented")
}
func (UnimplementedNetemServer) SetIfState(context.Context, *NodeIfStateRequest) (*AckResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetIfState not implemented")
}
func (UnimplementedNetemServer) Capture(*NodeInterfaceRequest, Netem_CaptureServer) error {
	return status.Errorf(codes.Unimplemented, "method Capture not implemented")
}
func (UnimplementedNetemServer) CopyFrom(*CopyMsg, Netem_CopyFromServer) error {
	return status.Errorf(codes.Unimplemented, "method CopyFrom not implemented")
}
func (UnimplementedNetemServer) CopyTo(Netem_CopyToServer) error {
	return status.Errorf(codes.Unimplemented, "method CopyTo not implemented")
}
func (UnimplementedNetemServer) LinkUpdate(context.Context, *LinkRequest) (*AckResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method LinkUpdate not implemented")
}
func (UnimplementedNetemServer) mustEmbedUnimplementedNetemServer() {}

// UnsafeNetemServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to NetemServer will
// result in compilation errors.
type UnsafeNetemServer interface {
	mustEmbedUnimplementedNetemServer()
}

func RegisterNetemServer(s grpc.ServiceRegistrar, srv NetemServer) {
	s.RegisterService(&Netem_ServiceDesc, srv)
}

func _Netem_ServerGetVersion_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NetemServer).ServerGetVersion(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Netem_ServerGetVersion_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NetemServer).ServerGetVersion(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Netem_ServerPullImages_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(emptypb.Empty)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(NetemServer).ServerPullImages(m, &netemServerPullImagesServer{stream})
}

type Netem_ServerPullImagesServer interface {
	Send(*PullSrvMsg) error
	grpc.ServerStream
}

type netemServerPullImagesServer struct {
	grpc.ServerStream
}

func (x *netemServerPullImagesServer) Send(m *PullSrvMsg) error {
	return x.ServerStream.SendMsg(m)
}

func _Netem_ServerCleanContainers_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NetemServer).ServerCleanContainers(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Netem_ServerCleanContainers_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NetemServer).ServerCleanContainers(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Netem_ProjectGetMany_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NetemServer).ProjectGetMany(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Netem_ProjectGetMany_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NetemServer).ProjectGetMany(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Netem_ProjectOpen_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(OpenRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NetemServer).ProjectOpen(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Netem_ProjectOpen_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NetemServer).ProjectOpen(ctx, req.(*OpenRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Netem_ProjectClose_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(ProjectRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(NetemServer).ProjectClose(m, &netemProjectCloseServer{stream})
}

type Netem_ProjectCloseServer interface {
	Send(*ProjectCloseMsg) error
	grpc.ServerStream
}

type netemProjectCloseServer struct {
	grpc.ServerStream
}

func (x *netemProjectCloseServer) Send(m *ProjectCloseMsg) error {
	return x.ServerStream.SendMsg(m)
}

func _Netem_ProjectSave_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(ProjectRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(NetemServer).ProjectSave(m, &netemProjectSaveServer{stream})
}

type Netem_ProjectSaveServer interface {
	Send(*ProjectSaveMsg) error
	grpc.ServerStream
}

type netemProjectSaveServer struct {
	grpc.ServerStream
}

func (x *netemProjectSaveServer) Send(m *ProjectSaveMsg) error {
	return x.ServerStream.SendMsg(m)
}

func _Netem_ProjectGetNodeConfigs_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ProjectRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NetemServer).ProjectGetNodeConfigs(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Netem_ProjectGetNodeConfigs_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NetemServer).ProjectGetNodeConfigs(ctx, req.(*ProjectRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Netem_ProjectGetStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ProjectRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NetemServer).ProjectGetStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Netem_ProjectGetStatus_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NetemServer).ProjectGetStatus(ctx, req.(*ProjectRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Netem_ReadNetworkFile_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ProjectRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NetemServer).ReadNetworkFile(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Netem_ReadNetworkFile_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NetemServer).ReadNetworkFile(ctx, req.(*ProjectRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Netem_WriteNetworkFile_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(WNetworkRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NetemServer).WriteNetworkFile(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Netem_WriteNetworkFile_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NetemServer).WriteNetworkFile(ctx, req.(*WNetworkRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Netem_Check_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ProjectRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NetemServer).Check(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Netem_Check_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NetemServer).Check(ctx, req.(*ProjectRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Netem_TopologyReload_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(ProjectRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(NetemServer).TopologyReload(m, &netemTopologyReloadServer{stream})
}

type Netem_TopologyReloadServer interface {
	Send(*TopologyRunMsg) error
	grpc.ServerStream
}

type netemTopologyReloadServer struct {
	grpc.ServerStream
}

func (x *netemTopologyReloadServer) Send(m *TopologyRunMsg) error {
	return x.ServerStream.SendMsg(m)
}

func _Netem_TopologyRun_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(ProjectRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(NetemServer).TopologyRun(m, &netemTopologyRunServer{stream})
}

type Netem_TopologyRunServer interface {
	Send(*TopologyRunMsg) error
	grpc.ServerStream
}

type netemTopologyRunServer struct {
	grpc.ServerStream
}

func (x *netemTopologyRunServer) Send(m *TopologyRunMsg) error {
	return x.ServerStream.SendMsg(m)
}

func _Netem_TopologyStartAll_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ProjectRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NetemServer).TopologyStartAll(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Netem_TopologyStartAll_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NetemServer).TopologyStartAll(ctx, req.(*ProjectRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Netem_TopologyStopAll_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ProjectRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NetemServer).TopologyStopAll(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Netem_TopologyStopAll_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NetemServer).TopologyStopAll(ctx, req.(*ProjectRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Netem_ReadConfigFiles_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NodeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NetemServer).ReadConfigFiles(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Netem_ReadConfigFiles_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NetemServer).ReadConfigFiles(ctx, req.(*NodeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Netem_CanRunConsole_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NodeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NetemServer).CanRunConsole(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Netem_CanRunConsole_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NetemServer).CanRunConsole(ctx, req.(*NodeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Netem_Console_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(NetemServer).Console(&netemConsoleServer{stream})
}

type Netem_ConsoleServer interface {
	Send(*ConsoleSrvMsg) error
	Recv() (*ConsoleCltMsg, error)
	grpc.ServerStream
}

type netemConsoleServer struct {
	grpc.ServerStream
}

func (x *netemConsoleServer) Send(m *ConsoleSrvMsg) error {
	return x.ServerStream.SendMsg(m)
}

func (x *netemConsoleServer) Recv() (*ConsoleCltMsg, error) {
	m := new(ConsoleCltMsg)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _Netem_Start_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NodeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NetemServer).Start(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Netem_Start_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NetemServer).Start(ctx, req.(*NodeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Netem_Stop_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NodeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NetemServer).Stop(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Netem_Stop_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NetemServer).Stop(ctx, req.(*NodeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Netem_Restart_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NodeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NetemServer).Restart(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Netem_Restart_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NetemServer).Restart(ctx, req.(*NodeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Netem_SetIfState_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NodeIfStateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NetemServer).SetIfState(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Netem_SetIfState_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NetemServer).SetIfState(ctx, req.(*NodeIfStateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Netem_Capture_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(NodeInterfaceRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(NetemServer).Capture(m, &netemCaptureServer{stream})
}

type Netem_CaptureServer interface {
	Send(*CaptureSrvMsg) error
	grpc.ServerStream
}

type netemCaptureServer struct {
	grpc.ServerStream
}

func (x *netemCaptureServer) Send(m *CaptureSrvMsg) error {
	return x.ServerStream.SendMsg(m)
}

func _Netem_CopyFrom_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(CopyMsg)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(NetemServer).CopyFrom(m, &netemCopyFromServer{stream})
}

type Netem_CopyFromServer interface {
	Send(*CopyMsg) error
	grpc.ServerStream
}

type netemCopyFromServer struct {
	grpc.ServerStream
}

func (x *netemCopyFromServer) Send(m *CopyMsg) error {
	return x.ServerStream.SendMsg(m)
}

func _Netem_CopyTo_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(NetemServer).CopyTo(&netemCopyToServer{stream})
}

type Netem_CopyToServer interface {
	SendAndClose(*AckResponse) error
	Recv() (*CopyMsg, error)
	grpc.ServerStream
}

type netemCopyToServer struct {
	grpc.ServerStream
}

func (x *netemCopyToServer) SendAndClose(m *AckResponse) error {
	return x.ServerStream.SendMsg(m)
}

func (x *netemCopyToServer) Recv() (*CopyMsg, error) {
	m := new(CopyMsg)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _Netem_LinkUpdate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LinkRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NetemServer).LinkUpdate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Netem_LinkUpdate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NetemServer).LinkUpdate(ctx, req.(*LinkRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// Netem_ServiceDesc is the grpc.ServiceDesc for Netem service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Netem_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "netem.Netem",
	HandlerType: (*NetemServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ServerGetVersion",
			Handler:    _Netem_ServerGetVersion_Handler,
		},
		{
			MethodName: "ServerCleanContainers",
			Handler:    _Netem_ServerCleanContainers_Handler,
		},
		{
			MethodName: "ProjectGetMany",
			Handler:    _Netem_ProjectGetMany_Handler,
		},
		{
			MethodName: "ProjectOpen",
			Handler:    _Netem_ProjectOpen_Handler,
		},
		{
			MethodName: "ProjectGetNodeConfigs",
			Handler:    _Netem_ProjectGetNodeConfigs_Handler,
		},
		{
			MethodName: "ProjectGetStatus",
			Handler:    _Netem_ProjectGetStatus_Handler,
		},
		{
			MethodName: "ReadNetworkFile",
			Handler:    _Netem_ReadNetworkFile_Handler,
		},
		{
			MethodName: "WriteNetworkFile",
			Handler:    _Netem_WriteNetworkFile_Handler,
		},
		{
			MethodName: "Check",
			Handler:    _Netem_Check_Handler,
		},
		{
			MethodName: "TopologyStartAll",
			Handler:    _Netem_TopologyStartAll_Handler,
		},
		{
			MethodName: "TopologyStopAll",
			Handler:    _Netem_TopologyStopAll_Handler,
		},
		{
			MethodName: "ReadConfigFiles",
			Handler:    _Netem_ReadConfigFiles_Handler,
		},
		{
			MethodName: "CanRunConsole",
			Handler:    _Netem_CanRunConsole_Handler,
		},
		{
			MethodName: "Start",
			Handler:    _Netem_Start_Handler,
		},
		{
			MethodName: "Stop",
			Handler:    _Netem_Stop_Handler,
		},
		{
			MethodName: "Restart",
			Handler:    _Netem_Restart_Handler,
		},
		{
			MethodName: "SetIfState",
			Handler:    _Netem_SetIfState_Handler,
		},
		{
			MethodName: "LinkUpdate",
			Handler:    _Netem_LinkUpdate_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "ServerPullImages",
			Handler:       _Netem_ServerPullImages_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "ProjectClose",
			Handler:       _Netem_ProjectClose_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "ProjectSave",
			Handler:       _Netem_ProjectSave_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "TopologyReload",
			Handler:       _Netem_TopologyReload_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "TopologyRun",
			Handler:       _Netem_TopologyRun_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "Console",
			Handler:       _Netem_Console_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
		{
			StreamName:    "Capture",
			Handler:       _Netem_Capture_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "CopyFrom",
			Handler:       _Netem_CopyFrom_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "CopyTo",
			Handler:       _Netem_CopyTo_Handler,
			ClientStreams: true,
		},
	},
	Metadata: "internal/proto/netem.proto",
}
